<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mek Tycoon - Glyph Forge Probability Sphere V10</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0a;
            color: #ffcc00;
            font-family: 'Share Tech Mono', monospace;
            overflow: hidden;
            position: relative;
            user-select: none;
        }
        
        /* CRT Screen Effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
        }
        
        /* Main Container */
        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        /* Canvas Container */
        #canvas-container {
            width: 600px;
            height: 600px;
            border: 3px solid #ffcc00;
            border-radius: 10px;
            position: relative;
            background: radial-gradient(ellipse at center, rgba(255, 204, 0, 0.05) 0%, transparent 70%);
            box-shadow: 
                0 0 50px rgba(255, 204, 0, 0.3),
                inset 0 0 50px rgba(255, 204, 0, 0.1);
            cursor: grab;
            margin-bottom: 20px;
        }
        
        #canvas-container canvas {
            cursor: grab;
        }
        
        #canvas-container.dragging canvas {
            cursor: grabbing;
        }
        
        /* Launch instruction text */
        .launch-text {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffcc00;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
            opacity: 0.8;
            transition: opacity 0.3s;
            white-space: nowrap;
        }
        
        .launch-text.hidden {
            opacity: 0;
        }
        
        /* Wind Indicator - VISIBLE */
        .wind-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            pointer-events: none;
            z-index: 90;
        }
        
        .wind-arrow {
            width: 50px;
            height: 50px;
            position: relative;
            filter: drop-shadow(0 0 5px rgba(255, 204, 0, 0.5));
        }
        
        .wind-arrow svg {
            width: 100%;
            height: 100%;
        }
        
        .wind-text {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #ffcc00;
            text-shadow: 0 0 5px rgba(255, 204, 0, 0.5);
            white-space: nowrap;
        }
        
        /* Power Indicator - Much larger */
        .power-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .power-indicator.active {
            opacity: 1;
        }
        
        .power-ring {
            width: 500px;
            height: 500px;
            position: relative;
        }
        
        .power-arc {
            position: absolute;
            top: 0;
            left: 0;
            width: 500px;
            height: 500px;
            filter: drop-shadow(0 0 10px rgba(255, 204, 0, 0));
            transition: filter 0.2s;
        }
        
        .power-arc.glowing {
            filter: drop-shadow(0 0 30px rgba(255, 204, 0, 1)) 
                    drop-shadow(0 0 60px rgba(255, 204, 0, 0.8))
                    drop-shadow(0 0 90px rgba(255, 102, 0, 0.6));
        }
        
        .power-dot {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #ffcc00;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            margin-left: -6px;
            margin-top: -6px;
            box-shadow: 0 0 20px #ffcc00;
            transform: translate(0, -140px);
            transform-origin: 6px 146px;
        }
        
        /* Crosshair - always visible */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 99;
            opacity: 0.8;
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #ffcc00;
            box-shadow: 0 0 10px #ffcc00;
        }
        
        .crosshair::before {
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            transform: translateY(-50%);
        }
        
        .crosshair::after {
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            transform: translateX(-50%);
        }
        
        /* Crosshair ring */
        .crosshair-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border: 2px solid rgba(255, 204, 0, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 98;
        }
        
        /* Horizontal Probability Matrix */
        .probability-matrix {
            display: flex;
            gap: 15px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffcc00;
            padding: 15px;
            border-radius: 5px;
            align-items: center;
        }
        
        .matrix-title {
            color: #ffcc00;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-right: 10px;
        }
        
        .matrix-items {
            display: flex;
            gap: 10px;
        }
        
        .matrix-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            border-radius: 5px;
            transition: all 0.1s;
            min-width: 45px;
        }
        
        .matrix-color {
            width: 35px;
            height: 35px;
            border: 1px solid #333;
            border-radius: 3px;
            margin-bottom: 5px;
            transition: all 0.1s;
        }
        
        .matrix-color.glow {
            box-shadow: 0 0 15px currentColor, 0 0 25px currentColor;
            border-color: currentColor;
            transform: scale(1.1);
        }
        
        .matrix-prob {
            color: #999;
            font-size: 10px;
            transition: color 0.1s;
        }
        
        .matrix-item.active .matrix-prob {
            color: #ffcc00;
            font-weight: bold;
        }
        
        /* Controls */
        .controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .btn {
            padding: 10px 20px;
            background: linear-gradient(45deg, #1a1a1a, #2a2a2a);
            border: 2px solid #ffcc00;
            color: #ffcc00;
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 1px;
        }
        
        .btn:hover {
            background: linear-gradient(45deg, #2a2a2a, #3a3a3a);
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.5);
        }
        
        /* Result Display */
        .result {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ffcc00;
            padding: 20px 40px;
            border-radius: 5px;
            font-size: 24px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 500;
        }
        
        .result.show {
            opacity: 1;
            animation: result-pulse 0.5s ease-out;
        }
        
        @keyframes result-pulse {
            0% { transform: translate(-50%, -50%) scale(0.8); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        .result-value {
            color: #ffcc00;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 30px #ffcc00;
        }
        
        .result-label {
            font-size: 16px;
            color: #999;
            margin-top: 10px;
        }
        
        /* Pattern Toggle */
        .pattern-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffcc00;
            padding: 10px;
            border-radius: 5px;
        }
        
        .pattern-btn {
            display: block;
            width: 140px;
            padding: 6px;
            margin: 4px 0;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #999;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .pattern-btn.active {
            border-color: #ffcc00;
            color: #ffcc00;
        }
        
        /* Info Panel */
        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            padding: 10px;
            font-size: 10px;
            color: #666;
            max-width: 200px;
        }
        
        /* Lighting Toggle */
        .lighting-toggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffcc00;
            padding: 10px;
            border-radius: 5px;
        }
        
        .lighting-btn {
            display: block;
            width: 120px;
            padding: 6px;
            margin: 4px 0;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #999;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .lighting-btn.active {
            border-color: #ffcc00;
            color: #ffcc00;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <button class="btn" id="bias-btn">RARITY: MEDIUM</button>
            <div style="color: #666; font-size: 11px;">WIND: <span id="wind-status" style="color: #ffcc00;">ACTIVE</span></div>
        </div>
        
        <div id="canvas-container">
            <div class="crosshair"></div>
            <div class="crosshair-ring"></div>
            <div class="launch-text" id="launch-text">DRAG SPHERE TO LAUNCH</div>
            <div class="power-indicator" id="power-indicator">
                <div class="power-ring">
                    <svg class="power-arc" id="power-arc-svg" width="500" height="500">
                        <circle cx="250" cy="250" r="140" fill="none" stroke="rgba(255,204,0,0.2)" stroke-width="4"/>
                        <circle cx="250" cy="250" r="140" fill="none" stroke="#ffcc00" stroke-width="8"
                                stroke-dasharray="0 880" id="power-arc-fill" stroke-linecap="round"/>
                    </svg>
                    <div class="power-dot" id="power-dot"></div>
                </div>
            </div>
            
            <div class="wind-indicator">
                <div class="wind-arrow" id="wind-arrow">
                    <svg viewBox="0 0 50 50">
                        <polygon points="25,5 35,35 25,30 15,35" fill="#ffcc00" opacity="0.8"/>
                    </svg>
                </div>
                <div class="wind-text" id="wind-text">5 mph</div>
            </div>
        </div>
        
        <div class="probability-matrix">
            <div class="matrix-title">ZONES</div>
            <div class="matrix-items" id="matrix-items"></div>
        </div>
        
        <div class="result" id="result">
            <div>GLYPH FORGED!</div>
            <div class="result-value" id="result-value">-</div>
            <div class="result-label" id="result-label"></div>
        </div>
        
        <div class="pattern-toggle">
            <div style="color: #ffcc00; font-size: 12px; margin-bottom: 10px;">ZONE PATTERN</div>
            <button class="pattern-btn active" data-pattern="camo">DIGITAL CAMO</button>
            <button class="pattern-btn" data-pattern="solid">SOLID ZONES</button>
            <button class="pattern-btn" data-pattern="organic">ORGANIC</button>
            <button class="pattern-btn" data-pattern="lines">LINES</button>
        </div>
        
        <div class="lighting-toggle">
            <div style="color: #ffcc00; font-size: 12px; margin-bottom: 10px;">LIGHTING</div>
            <button class="lighting-btn active" data-lighting="standard">STANDARD</button>
            <button class="lighting-btn" data-lighting="neon">NEON GLOW</button>
            <button class="lighting-btn" data-lighting="dark">DARK MODE</button>
        </div>
        
        <div class="info-panel">
            <div>SYSTEM: MK-TYCOON-10.0</div>
            <div>MODE: WIND_ACTIVE</div>
            <div>DETAIL: ULTRA</div>
            <div>ZONES: BALANCED</div>
        </div>
    </div>
    
    <script src="three.min.js"></script>
    <script>
        // Configuration
        let rarityBias = 'medium';
        let currentPattern = 'camo';
        let currentLighting = 'standard';
        let hasSpun = false; // Track if we've completed a spin
        
        // Better distributed zone probabilities
        const biasProfiles = {
            low: [28, 22, 18, 12, 8, 5, 3.5, 2, 1, 0.5],
            medium: [12, 12, 11, 11, 10, 10, 10, 9, 8, 7],
            high: [5, 6, 7, 8, 9, 11, 13, 14, 13, 14]
        };
        
        // Better color variety across zones
        const zoneColorMapping = {
            low: [0x404040, 0x505050, 0x606060, 0x707070, 0x808080, 0x909090, 0xa0a000, 0xccaa00, 0xff9900, 0xff0000],
            medium: [0x404040, 0x505050, 0x606060, 0x808080, 0x909090, 0xa0a000, 0xb0b000, 0xccaa00, 0xff9900, 0xff6600],
            high: [0x303030, 0x404040, 0x505050, 0x707070, 0x909090, 0xb0b000, 0xccaa00, 0xffcc00, 0xff9900, 0xff6600]
        };
        
        // Wind system - ACTIVE with visible effect on sphere
        let windDirection = Math.random() * Math.PI * 2;
        let windStrength = 3 + Math.random() * 7;
        let windChangeInterval = null;
        let canChangeWind = true; // Only allow wind changes when not spinning
        
        function updateWind() {
            if (!canChangeWind) return; // Don't change wind during spin
            
            // Change wind randomly every 5-10 seconds
            windDirection = Math.random() * Math.PI * 2;
            windStrength = 3 + Math.random() * 7;
            
            const arrow = document.getElementById('wind-arrow');
            arrow.style.transform = `rotate(${windDirection * 180 / Math.PI + 90}deg)`;
            
            document.getElementById('wind-text').textContent = `${Math.round(windStrength)} mph`;
        }
        
        // Start wind changes
        function startWindChanges() {
            if (windChangeInterval) clearInterval(windChangeInterval);
            windChangeInterval = setInterval(updateWind, 5000 + Math.random() * 5000);
        }
        
        // Three.js Setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });
        
        renderer.setSize(600, 600);
        renderer.setPixelRatio(window.devicePixelRatio * 2); // Maximum quality
        container.appendChild(renderer.domElement);
        
        camera.position.z = 5;
        let cameraTarget = { z: 5 };
        
        // Lighting configurations
        let lights = {
            ambient: null,
            point: null,
            directional: null
        };
        
        function setupLighting() {
            // Remove existing lights
            if (lights.ambient) scene.remove(lights.ambient);
            if (lights.point) scene.remove(lights.point);
            if (lights.directional) scene.remove(lights.directional);
            
            if (currentLighting === 'standard') {
                lights.ambient = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(lights.ambient);
                
                lights.point = new THREE.PointLight(0xffcc00, 1, 100);
                lights.point.position.set(5, 5, 5);
                scene.add(lights.point);
            } else if (currentLighting === 'neon') {
                lights.ambient = new THREE.AmbientLight(0xffffff, 0.3);
                scene.add(lights.ambient);
                
                lights.point = new THREE.PointLight(0xff00ff, 2, 100);
                lights.point.position.set(5, 5, 5);
                scene.add(lights.point);
                
                const point2 = new THREE.PointLight(0x00ffff, 2, 100);
                point2.position.set(-5, -5, 5);
                scene.add(point2);
                
                lights.directional = point2;
            } else if (currentLighting === 'dark') {
                lights.ambient = new THREE.AmbientLight(0xffffff, 0.2);
                scene.add(lights.ambient);
                
                lights.point = new THREE.PointLight(0xffcc00, 0.5, 100);
                lights.point.position.set(0, 0, 10);
                scene.add(lights.point);
                
                lights.directional = new THREE.DirectionalLight(0xffffff, 0.3);
                lights.directional.position.set(1, 1, 1);
                scene.add(lights.directional);
            }
        }
        
        setupLighting();
        
        // Create Sphere (not icosahedron) for better UV mapping at poles
        const geometry = new THREE.SphereGeometry(1.5, 64, 64); // High detail sphere // Increased to 6 for ultra smooth
        
        // Create material with patterns
        function createPolyhedronMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');
            
            const colors = zoneColorMapping[rarityBias];
            const probabilities = biasProfiles[rarityBias];
            
            // Create weighted distribution
            const distribution = [];
            colors.forEach((color, index) => {
                const pixelCount = Math.round((probabilities[index] / 100) * 1000);
                for (let i = 0; i < pixelCount; i++) {
                    distribution.push(color);
                }
            });
            
            // Shuffle
            distribution.sort(() => Math.random() - 0.5);
            
            if (currentPattern === 'camo') {
                // Digital camo
                const cellSize = 32;
                let distIndex = 0;
                
                for (let y = 0; y < canvas.height; y += cellSize) {
                    for (let x = 0; x < canvas.width; x += cellSize) {
                        const color = distribution[distIndex % distribution.length];
                        distIndex++;
                        
                        const r = (color >> 16) & 255;
                        const g = (color >> 8) & 255;
                        const b = color & 255;
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(x, y, cellSize, cellSize);
                    }
                }
            } else if (currentPattern === 'solid') {
                // Solid horizontal bands
                let y = 0;
                
                probabilities.forEach((prob, index) => {
                    const height = (prob / 100) * canvas.height;
                    const color = colors[index];
                    const r = (color >> 16) & 255;
                    const g = (color >> 8) & 255;
                    const b = color & 255;
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(0, y, canvas.width, height);
                    
                    y += height;
                });
            } else if (currentPattern === 'organic') {
                // Voronoi cells
                const points = [];
                
                colors.forEach((color, index) => {
                    const numPoints = Math.max(1, Math.round(probabilities[index] / 3));
                    for (let i = 0; i < numPoints; i++) {
                        points.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height,
                            color: color
                        });
                    }
                });
                
                // Fast Voronoi
                for (let y = 0; y < canvas.height; y += 4) {
                    for (let x = 0; x < canvas.width; x += 4) {
                        let minDist = Infinity;
                        let closestPoint = points[0];
                        
                        points.forEach(point => {
                            const dist = Math.sqrt(
                                Math.pow(x - point.x, 2) + 
                                Math.pow(y - point.y, 2)
                            );
                            if (dist < minDist) {
                                minDist = dist;
                                closestPoint = point;
                            }
                        });
                        
                        const color = closestPoint.color;
                        const r = (color >> 16) & 255;
                        const g = (color >> 8) & 255;
                        const b = color & 255;
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(x, y, 4, 4);
                    }
                }
            } else {
                // Lines pattern with antialiasing
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                const bgColor = colors[0];
                const bgR = (bgColor >> 16) & 255;
                const bgG = (bgColor >> 8) & 255;
                const bgB = bgColor & 255;
                ctx.fillStyle = `rgb(${bgR}, ${bgG}, ${bgB})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Smooth lines
                probabilities.forEach((prob, index) => {
                    const lineCount = Math.max(1, Math.round(prob / 2));
                    const color = colors[index];
                    const r = (color >> 16) & 255;
                    const g = (color >> 8) & 255;
                    const b = color & 255;
                    
                    for (let i = 0; i < lineCount; i++) {
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                        ctx.lineWidth = 8 + Math.random() * 16;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        ctx.beginPath();
                        const startX = Math.random() * canvas.width;
                        const startY = Math.random() * canvas.height;
                        const endX = startX + (Math.random() - 0.5) * 400;
                        const endY = startY + (Math.random() - 0.5) * 400;
                        
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                });
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            // Improve UV wrapping to reduce pole pinching
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            
            const materialOptions = {
                map: texture,
                shininess: 80,
                specular: 0x222222
            };
            
            if (currentLighting === 'neon') {
                materialOptions.emissive = 0x111111;
                materialOptions.emissiveIntensity = 0.3;
            }
            
            return new THREE.MeshPhongMaterial(materialOptions);
        }
        
        // Create polyhedron
        let polyMaterial = createPolyhedronMaterial();
        const polyhedron = new THREE.Mesh(geometry, polyMaterial);
        scene.add(polyhedron);
        
        // Rotation state - SIMPLE AND CLEAN
        let isSpinning = false;
        let spinStartTime = 0;
        let velocityX = 0;
        let velocityY = 0;
        
        // Drag controls
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragCurrent = { x: 0, y: 0 };
        
        function getEventPosition(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;
            return { x, y };
        }
        
        function startDrag(e) {
            if (isSpinning) return;
            
            isDragging = true;
            const pos = getEventPosition(e);
            dragStart = pos;
            dragCurrent = pos;
            
            container.classList.add('dragging');
            document.getElementById('power-indicator').classList.add('active');
            document.getElementById('launch-text').classList.add('hidden');
            
            cameraTarget.z = 5;
            
            e.preventDefault();
        }
        
        function updateDrag(e) {
            if (!isDragging) return;
            
            dragCurrent = getEventPosition(e);
            
            const dx = dragCurrent.x - dragStart.x;
            const dy = dragCurrent.y - dragStart.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = 250;
            const power = Math.min(distance / maxDistance, 1);
            const angle = Math.atan2(dy, dx);
            
            // Update larger power arc
            const arcFill = document.getElementById('power-arc-fill');
            const arcSvg = document.getElementById('power-arc-svg');
            const circumference = 880; // 2 * PI * 140
            const arcLength = power * circumference;
            arcFill.style.strokeDasharray = `${arcLength} ${circumference}`;
            arcFill.style.transform = `rotate(${angle * 180 / Math.PI - 90}deg)`;
            arcFill.style.transformOrigin = 'center';
            
            // Progressive glow
            if (power > 0.3) {
                arcSvg.classList.add('glowing');
                arcFill.style.strokeWidth = 6 + power * 6;
                arcFill.style.stroke = power > 0.7 ? '#ff6600' : '#ffcc00';
            } else {
                arcSvg.classList.remove('glowing');
                arcFill.style.strokeWidth = 8;
                arcFill.style.stroke = '#ffcc00';
            }
            
            // Update dot position
            const dot = document.getElementById('power-dot');
            const radius = 140;
            const dotX = Math.cos(angle) * radius;
            const dotY = Math.sin(angle) * radius;
            dot.style.transform = `translate(${dotX}px, ${dotY}px)`;
            dot.style.width = (8 + power * 16) + 'px';
            dot.style.height = (8 + power * 16) + 'px';
            dot.style.marginLeft = -(4 + power * 8) + 'px';
            dot.style.marginTop = -(4 + power * 8) + 'px';
            
            e.preventDefault();
        }
        
        function endDrag(e) {
            if (!isDragging) return;
            
            isDragging = false;
            container.classList.remove('dragging');
            document.getElementById('power-indicator').classList.remove('active');
            
            const dx = dragCurrent.x - dragStart.x;
            const dy = dragCurrent.y - dragStart.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 10) {
                const maxDistance = 250;
                const power = Math.min(distance / maxDistance, 1);
                const minPower = 0.35;
                const actualPower = minPower + (1 - minPower) * power;
                
                // SIMPLE VELOCITY - NO Z AXIS
                velocityX = -(dy / distance) * actualPower * 0.2;
                velocityY = (dx / distance) * actualPower * 0.2;
                
                isSpinning = true;
                hasSpun = false;
                spinStartTime = Date.now();
                canChangeWind = false; // Lock wind during spin
                
                document.getElementById('launch-text').classList.add('hidden');
                
                setTimeout(updateWind, 1000);
            } else {
                // Return to initial state if no significant drag
                document.getElementById('launch-text').classList.remove('hidden');
            }
            
            e.preventDefault();
        }
        
        // Event listeners - entire canvas is draggable
        renderer.domElement.addEventListener('mousedown', startDrag);
        document.addEventListener('mousemove', updateDrag);
        document.addEventListener('mouseup', endDrag);
        
        renderer.domElement.addEventListener('touchstart', startDrag);
        document.addEventListener('touchmove', updateDrag);
        document.addEventListener('touchend', endDrag);
        
        // Pattern switching
        document.querySelectorAll('.pattern-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentPattern = btn.dataset.pattern;
                
                polyhedron.material.dispose();
                polyhedron.material = createPolyhedronMaterial();
            });
        });
        
        // Lighting switching
        document.querySelectorAll('.lighting-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.lighting-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLighting = btn.dataset.lighting;
                
                setupLighting();
                polyhedron.material.dispose();
                polyhedron.material = createPolyhedronMaterial();
            });
        });
        
        // Zone detection - accurate and instant
        let currentZone = null;
        let lastDetectTime = 0;
        
        function detectCurrentZone() {
            const now = Date.now();
            if (now - lastDetectTime < 16) return; // 60fps max
            lastDetectTime = now;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const intersects = raycaster.intersectObject(polyhedron);
            if (intersects.length > 0) {
                const uv = intersects[0].uv;
                if (!uv) return;
                
                // Clamp UV coordinates to avoid pole issues
                const clampedU = Math.max(0.05, Math.min(0.95, uv.x));
                const clampedV = Math.max(0.05, Math.min(0.95, uv.y));
                
                const canvas = polyhedron.material.map.image;
                const x = Math.floor(clampedU * canvas.width);
                const y = Math.floor((1 - clampedV) * canvas.height);
                
                const ctx = canvas.getContext('2d');
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                
                // Match pixel to zone
                const colors = zoneColorMapping[rarityBias];
                let detectedZone = 1;
                let minDist = Infinity;
                
                colors.forEach((color, index) => {
                    const r = (color >> 16) & 255;
                    const g = (color >> 8) & 255;
                    const b = color & 255;
                    
                    const dist = Math.sqrt(
                        Math.pow(pixel[0] - r, 2) +
                        Math.pow(pixel[1] - g, 2) +
                        Math.pow(pixel[2] - b, 2)
                    );
                    
                    if (dist < minDist) {
                        minDist = dist;
                        detectedZone = index + 1;
                    }
                });
                
                if (detectedZone !== currentZone) {
                    currentZone = detectedZone;
                    updateMatrixHighlight(detectedZone);
                }
            }
        }
        
        function updateMatrixHighlight(zone) {
            const colors = zoneColorMapping[rarityBias];
            const highlightColor = colors[zone - 1];
            
            document.querySelectorAll('.matrix-item').forEach((item, index) => {
                const itemColor = colors[index];
                const isActive = itemColor === highlightColor;
                
                item.classList.toggle('active', isActive);
                
                const colorDiv = item.querySelector('.matrix-color');
                if (isActive) {
                    colorDiv.classList.add('glow');
                    const hex = '#' + itemColor.toString(16).padStart(6, '0');
                    colorDiv.style.setProperty('--glow-color', hex);
                } else {
                    colorDiv.classList.remove('glow');
                }
            });
        }
        
        // Animation loop - CLEAN PHYSICS
        function animate() {
            requestAnimationFrame(animate);
            
            if (camera.position.z !== cameraTarget.z) {
                camera.position.z += (cameraTarget.z - camera.position.z) * 0.1;
            }
            
            if (isSpinning) {
                // Proper bowling ball physics - velocity drives rotation
                polyhedron.rotation.x += velocityX;
                polyhedron.rotation.y += velocityY;
                
                // Apply wind as constant drift (not acceleration)
                const windInfluence = 0.0001 * (windStrength / 10);
                const windX = Math.sin(windDirection) * windInfluence;
                const windY = Math.cos(windDirection) * windInfluence;
                
                // Add wind drift directly to rotation (like lateral force on bowling ball)
                polyhedron.rotation.x += windX;
                polyhedron.rotation.y += windY;
                
                // Only apply friction to velocity (proper deceleration)
                const friction = 0.993; // Tuned for 40% longer spin
                velocityX *= friction;
                velocityY *= friction;
                
                // Detect zones while spinning
                detectCurrentZone();
                
                // Stop conditions (increased time for 40% longer spin)
                const spinTime = Date.now() - spinStartTime;
                const speedMagnitude = Math.abs(velocityX) + Math.abs(velocityY);
                
                if (spinTime > 21000 || speedMagnitude < 0.001) { // 40% longer than original
                    velocityX = 0;
                    velocityY = 0;
                    isSpinning = false;
                    hasSpun = true;
                    canChangeWind = true; // Allow wind changes again
                    calculateFinalResult();
                    
                    // Schedule next wind change
                    setTimeout(updateWind, 2000);
                }
            } else if (!isDragging && !hasSpun) {
                // Apply constant wind when idle - gentler effect
                const windX = Math.sin(windDirection) * 0.002 * (windStrength / 10);
                const windY = Math.cos(windDirection) * 0.002 * (windStrength / 10);
                polyhedron.rotation.x += windX;
                polyhedron.rotation.y += windY;
                
                // Detect zones during idle
                detectCurrentZone();
            }
            // If hasSpun is true, sphere stays completely still
            
            renderer.render(scene, camera);
        }
        
        // Calculate final result
        function calculateFinalResult() {
            cameraTarget.z = 2.5;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const intersects = raycaster.intersectObject(polyhedron);
            if (intersects.length > 0) {
                const uv = intersects[0].uv;
                if (!uv) return;
                
                // Clamp UV coordinates to avoid pole issues
                const clampedU = Math.max(0.05, Math.min(0.95, uv.x));
                const clampedV = Math.max(0.05, Math.min(0.95, uv.y));
                
                const canvas = polyhedron.material.map.image;
                const x = Math.floor(clampedU * canvas.width);
                const y = Math.floor((1 - clampedV) * canvas.height);
                
                const ctx = canvas.getContext('2d');
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                
                const colors = zoneColorMapping[rarityBias];
                let finalZone = 1;
                let minDist = Infinity;
                
                colors.forEach((color, index) => {
                    const r = (color >> 16) & 255;
                    const g = (color >> 8) & 255;
                    const b = color & 255;
                    
                    const dist = Math.sqrt(
                        Math.pow(pixel[0] - r, 2) +
                        Math.pow(pixel[1] - g, 2) +
                        Math.pow(pixel[2] - b, 2)
                    );
                    
                    if (dist < minDist) {
                        minDist = dist;
                        finalZone = index + 1;
                    }
                });
                
                showResult(finalZone);
            }
        }
        
        // Show result
        function showResult(zone) {
            const resultEl = document.getElementById('result');
            const resultValue = document.getElementById('result-value');
            const resultLabel = document.getElementById('result-label');
            
            const colors = zoneColorMapping[rarityBias];
            
            resultValue.textContent = zone;
            resultValue.style.color = `#${colors[zone - 1].toString(16).padStart(6, '0')}`;
            
            if (zone <= 7) {
                resultLabel.textContent = '1 Buff';
            } else if (zone === 8) {
                resultLabel.textContent = '2 Buffs';
            } else {
                resultLabel.textContent = '3 Buffs';
            }
            
            resultEl.classList.add('show');
            updateMatrixHighlight(zone);
            
            setTimeout(() => {
                resultEl.classList.remove('show');
                cameraTarget.z = 5;
                hasSpun = false; // Reset for next spin
                document.getElementById('launch-text').classList.remove('hidden');
            }, 4000);
        }
        
        // Bias button
        document.getElementById('bias-btn').addEventListener('click', () => {
            const biases = ['low', 'medium', 'high'];
            const currentIndex = biases.indexOf(rarityBias);
            rarityBias = biases[(currentIndex + 1) % 3];
            
            document.getElementById('bias-btn').textContent = `RARITY: ${rarityBias.toUpperCase()}`;
            
            polyhedron.material.dispose();
            polyhedron.material = createPolyhedronMaterial();
            updateProbabilityMatrix();
        });
        
        // Update probability matrix
        function updateProbabilityMatrix() {
            const container = document.getElementById('matrix-items');
            const colors = zoneColorMapping[rarityBias];
            const probabilities = biasProfiles[rarityBias];
            
            container.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const item = document.createElement('div');
                item.className = 'matrix-item';
                const hex = '#' + colors[i].toString(16).padStart(6, '0');
                item.innerHTML = `
                    <div class="matrix-color" style="background: ${hex}; --glow-color: ${hex}"></div>
                    <div class="matrix-prob">${probabilities[i]}%</div>
                `;
                container.appendChild(item);
            }
        }
        
        // Initialize
        updateProbabilityMatrix();
        updateWind();
        startWindChanges();
        animate();
    </script>
</body>
</html>