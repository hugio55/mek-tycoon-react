"use client";

import React, { useState, useEffect, useRef, useCallback } from "react";
import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";
import StoryMissionCard from '@/components/StoryMissionCard';
import { StyleK } from '@/components/ui/ShowcaseCards';
import MekRecruitmentModalV4 from '@/app/contracts/components/MekRecruitmentModalV4';
import { generateSampleMeks } from '@/app/contracts/utils/helpers';
import { leastRareMechanisms } from './least-rare-mechanisms';
import { createSeededRandomFromString } from '@/lib/seeded-random';


interface StoryNode {
  id: string;
  label: string;
  storyNodeType: "normal" | "boss" | "event" | "final_boss";
  x: number;
  y: number;
  challenger?: boolean;
}

interface Connection {
  from: string;
  to: string;
}

interface ExtendedStoryNode extends StoryNode {
  level?: number;
  nodeType?: 'normal' | 'boss' | 'elite' | 'event' | 'final_boss';
  title?: string;
}

// Simple hash function to generate consistent values from node IDs
function hashCode(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
}

export default function StoryClimbPage() {
  // Check for preview mode from URL params
  const [previewMode, setPreviewMode] = useState(false);
  const [previewSeed, setPreviewSeed] = useState('1');
  const [previewChapter, setPreviewChapter] = useState(1);

  useEffect(() => {
    if (typeof window !== 'undefined') {
      const params = new URLSearchParams(window.location.search);
      const mode = params.get('preview');
      const seed = params.get('seed');
      const chapter = params.get('chapter');

      if (mode === 'true') {
        setPreviewMode(true);
        setPreviewSeed(seed || '1');
        setPreviewChapter(parseInt(chapter || '1'));
        // Start at normal zoom to see nodes properly
        setZoom(1);
        setViewportOffset(-250); // Start at bottom like normal
      }
    }
  }, []);

  const [selectedNode, setSelectedNode] = useState<StoryNode | null>(null);
  const [completedNodes, setCompletedNodes] = useState<Set<string>>(new Set(['start'])); // Start is always completed
  const [canvasSize, setCanvasSize] = useState({ width: 600, height: 900 }); // 2:3 aspect ratio
  const [viewportOffset, setViewportOffset] = useState(-250); // Start scrolled to absolute bottom of tree
  const [mounted, setMounted] = useState(false);
  const [nodeImages, setNodeImages] = useState<Map<string, HTMLImageElement>>(new Map());
  const [imagesLoaded, setImagesLoaded] = useState(false);
  const [eventImages, setEventImages] = useState<Map<string, HTMLImageElement>>(new Map());
  const [panOffset, setPanOffset] = useState({ x: 0, y: 0 }); // For panning the tree
  const [isPanning, setIsPanning] = useState(false);
  const [isMouseDown, setIsMouseDown] = useState(false);
  const [mouseDownPos, setMouseDownPos] = useState({ x: 0, y: 0 });
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [hasDragged, setHasDragged] = useState(false);
  const [showJumpButton, setShowJumpButton] = useState(false);
  const [isJumping, setIsJumping] = useState(false);
  const [zoom, setZoom] = useState(1);
  const [hoveredNode, setHoveredNode] = useState<StoryNode | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [hoverEffectStyle, setHoverEffectStyle] = useState(0); // Add missing hover effect style
  const [challengerFrameStyle, setChallengerFrameStyle] = useState<'spikes' | 'lightning' | 'sawblade' | 'flames' | 'crystals'>('spikes'); // For Challenger frame options
  const [challengerEffect, setChallengerEffect] = useState<'quantum1' | 'quantum2' | 'quantum3'>('quantum1'); // Challenger quantum variations
  const [animationTick, setAnimationTick] = useState(0); // Minimal state for animation redraws
  const animationIdRef = useRef<number | null>(null); // Track animation ID for cleanup
  const [showMekModal, setShowMekModal] = useState<string | null>(null);
  const [selectedMekSlot, setSelectedMekSlot] = useState<{ missionId: string; slotIndex: number } | null>(null);
  const [selectedMeks, setSelectedMeks] = useState<Record<string, any[]>>({});
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const autoScrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  // Load the V2 story tree (primary) with storyNodeType, or V1 as fallback
  const storyTrees = useQuery(api.storyTrees.getAllStoryTrees);
  const v2Tree = storyTrees?.find(tree => tree.name === "V2");
  const v1Tree = storyTrees?.find(tree => tree.name === "V1");
  const test5Tree = storyTrees?.find(tree => tree.name === "test 5");

  // Load event node configurations to get actual gold/XP values
  const eventConfigs = useQuery(api.eventNodeRewards.getConfigurations);
  const attempt2Config = eventConfigs?.find(config => config.name === "attempt 2!");

  // Parse configuration data once
  const [parsedConfig, setParsedConfig] = useState<any>(null);
  useEffect(() => {
    if (attempt2Config?.data) {
      try {
        const parsed = JSON.parse(attempt2Config.data);
        setParsedConfig(parsed);
        console.log('Parsed attempt 2! configuration:', parsed);
        // Log the structure to understand how to access the data
        if (parsed) {
          console.log('Config keys:', Object.keys(parsed));
          if (parsed.events) {
            console.log('Sample event:', parsed.events[0]);
          }
          if (parsed.nodes) {
            console.log('Sample node:', parsed.nodes[0]);
          }
        }
      } catch (e) {
        console.error('Failed to parse configuration:', e);
      }
    }
  }, [attempt2Config]);
  
  const [previewNodes, setPreviewNodes] = useState<StoryNode[] | null>(null);
  const [previewConnections, setPreviewConnections] = useState<Connection[] | null>(null);

  // Don't generate preview data - we'll use actual database trees
  useEffect(() => {
    if (previewMode) {
      // In preview mode, we just use the actual database trees (V2, V1, or test5)
      // The treeData will be set from the database queries below
      console.log('Preview mode active - using database tree data');
    }
  }, [previewMode]);

  // Always use database tree data (V2, V1, or test5)
  const treeData = v2Tree || v1Tree || test5Tree; // Use V2 if available, otherwise V1, then Test 5
  
  // Helper function to generate rewards based on node type and level
  const getNodeRewards = useCallback((node: ExtendedStoryNode) => {
    const baseRewards = [
      { name: "Common Power Chip", quantity: 2, chance: 75 },
      { name: "Bumblebee Essence", quantity: 1.5, chance: 45 },
      { name: "Paul Essence", quantity: 2, chance: 30 },
      { name: "DMT Canister", quantity: 1, chance: 15 },
      { name: "Rare Power Chip", quantity: 1, chance: 8 },
      { name: "Legendary Frame", quantity: 1, chance: 1 }
    ];
    
    // Adjust rewards based on node type
    if (node.storyNodeType === 'final_boss') {
      return baseRewards.map(r => ({
        ...r,
        quantity: (r.quantity || 1) * 3,
        chance: Math.min(100, r.chance * 1.5)
      }));
    } else if (node.storyNodeType === 'boss') {
      return baseRewards.map(r => ({
        ...r,
        quantity: (r.quantity || 1) * 2,
        chance: Math.min(100, r.chance * 1.2)
      }));
    } else if (node.storyNodeType === 'event') {
      return baseRewards.slice(0, 4); // Only first 4 rewards for events
    }
    
    return baseRewards;
  }, []);
  
  // Helper function to generate variation buffs based on node
  const getNodeVariationBuffs = useCallback((node: ExtendedStoryNode) => {
    const allBuffs = [
      "TASER", "LOG", "KEVLAR", "NUKE", "EXPOSED",
      "JADE", "SHAMROCK", "CLASSIC", "LIGHTNING", "CORRODED"
    ];
    
    // Use node ID to deterministically select buffs
    let hash = 0;
    for (let i = 0; i < node.id.length; i++) {
      hash = ((hash << 5) - hash) + node.id.charCodeAt(i);
      hash = hash & hash;
    }
    
    const startIndex = Math.abs(hash) % allBuffs.length;
    // For testing: randomly assign 3 or 8 buffs to see dynamic resizing
    const randomChoice = Math.abs(hash) % 3; // Use hash for deterministic "randomness"
    const buffCount = node.storyNodeType === 'final_boss' ? 8 :
                      node.storyNodeType === 'boss' ? 8 :
                      node.storyNodeType === 'event' ? (randomChoice === 0 ? 3 : 8) :
                      (randomChoice === 1 ? 3 : 8); // Mix of 3 and 8 for normal nodes
    
    const selectedBuffs = [];
    for (let i = 0; i < buffCount; i++) {
      const buffName = allBuffs[(startIndex + i) % allBuffs.length];
      selectedBuffs.push({
        id: buffName.toLowerCase(),
        name: buffName,
        bonus: node.storyNodeType === 'final_boss' ? "+20%" :
               node.storyNodeType === 'boss' ? "+15%" : "+10%"
      });
    }
    
    return selectedBuffs;
  }, []);
  
  // Helper function to get available slots for a node (for testing)
  const getNodeAvailableSlots = useCallback((node: ExtendedStoryNode) => {
    // Use node ID to deterministically select available slots
    let hash = 0;
    for (let i = 0; i < node.id.length; i++) {
      hash = ((hash << 5) - hash) + node.id.charCodeAt(i);
      hash = hash & hash;
    }

    // For testing: randomly assign 1, 4, or 8 available slots
    const slotOptions = [1, 4, 8];
    const slotIndex = Math.abs(hash >> 8) % slotOptions.length;
    return slotOptions[slotIndex];
  }, []);

  // Helper function to handle node deployment
  const handleNodeDeploy = useCallback((node: ExtendedStoryNode) => {
    if (!completedNodes.has(node.id)) {
      const newCompleted = new Set(completedNodes);
      newCompleted.add(node.id);
      setCompletedNodes(newCompleted);
    }
  }, [completedNodes]);

  // Handle mek slot click - opens the recruitment modal
  const handleMekSlotClick = useCallback((slotIndex: number) => {
    const nodeId = selectedNode?.id;
    if (nodeId) {
      setShowMekModal(nodeId);
      setSelectedMekSlot({ missionId: nodeId, slotIndex });
    }
  }, [selectedNode]);

  // Handle mek selection from modal
  const handleMekSelection = useCallback((mek: any, matchedTraits: any[], hasMatch: boolean) => {
    if (selectedMekSlot) {
      const { missionId, slotIndex } = selectedMekSlot;
      const meksForMission = selectedMeks[missionId] || [];
      const updatedMeks = [...meksForMission];
      // Store the mek with matched traits for success calculation
      updatedMeks[slotIndex] = { ...mek, matchedTraits };
      setSelectedMeks({ ...selectedMeks, [missionId]: updatedMeks });
    }
    setShowMekModal(null);
    setSelectedMekSlot(null);
  }, [selectedMekSlot, selectedMeks]);

  // Handle mek removal from slot
  const handleMekRemove = useCallback((slotIndex: number) => {
    const nodeId = selectedNode?.id;
    if (nodeId) {
      const meksForMission = selectedMeks[nodeId] || [];
      const updatedMeks = [...meksForMission];
      updatedMeks[slotIndex] = undefined;
      setSelectedMeks({ ...selectedMeks, [nodeId]: updatedMeks });
    }
  }, [selectedNode, selectedMeks]);

  // Calculate success chance based on selected meks and matched traits
  const calculateSuccessChance = useCallback((nodeId: string, baseChance: number, variationBuffs: any[]) => {
    const meksForMission = selectedMeks[nodeId] || [];
    let totalChance = baseChance;

    // Each mek with matched traits adds bonus to success chance
    meksForMission.forEach(mek => {
      if (mek?.matchedTraits?.length > 0) {
        // Each matched trait adds 10% to success chance
        totalChance += mek.matchedTraits.length * 10;
      }
    });

    // Cap at 95% max success chance
    return Math.min(95, totalChance);
  }, [selectedMeks]);
  
  // Helper function to get a deterministic mek image for each node
  const getMekImage = useCallback((nodeId: string, isForDetails: boolean = false): string => {
    // In preview mode, return a simple placeholder
    if (previewMode) {
      return '/mek-images/150px/000-000-000.webp';
    }

    // Find the node to get its Y position
    const node = treeData?.nodes?.find(n => n.id === nodeId);
    if (!node || node.storyNodeType !== 'normal') {
      // For non-mechanism nodes, use a default or return empty
      return '';
    }

    // Get all mechanism nodes sorted by Y position (bottom to top)
    const mechanismNodes = treeData?.nodes
      ?.filter(n => n.storyNodeType === 'normal')
      ?.sort((a, b) => a.y - b.y) || [];

    // Find the index of this node in the sorted list
    const nodeIndex = mechanismNodes.findIndex(n => n.id === nodeId);

    // Map to the least rare mechanisms (we have 400 of them)
    // If we have more nodes than mechanisms, wrap around
    const mechanismIndex = nodeIndex % leastRareMechanisms.length;
    const filename = leastRareMechanisms[mechanismIndex];

    // Return appropriate size based on usage
    if (isForDetails) {
      return `/mek-images/500px/${filename}`;
    } else {
      return `/mek-images/150px/${filename}`;
    }
  }, [treeData?.nodes?.length, previewMode]); // Use stable dependencies
  
  // Debug logging
  useEffect(() => {
    console.log("Story trees from database:", storyTrees);
    console.log("V1 tree:", v1Tree);
    console.log("V2 tree:", v2Tree);
    console.log("Test 5 tree:", test5Tree);
    console.log("Selected tree data:", treeData);
    if (treeData) {
      console.log("Number of nodes:", treeData.nodes?.length);
      console.log("Number of connections:", treeData.connections?.length);
      console.log("Node types breakdown:", {
        normal: treeData.nodes?.filter(n => n.storyNodeType === 'normal').length,
        event: treeData.nodes?.filter(n => n.storyNodeType === 'event').length,
        boss: treeData.nodes?.filter(n => n.storyNodeType === 'boss').length,
        final_boss: treeData.nodes?.filter(n => n.storyNodeType === 'final_boss').length,
        challenger: treeData.nodes?.filter(n => n.challenger).length
      });
      console.log("First few nodes:", treeData.nodes?.slice(0, 10));
    }
    console.log("Preview mode:", previewMode);
  }, [storyTrees, v1Tree, v2Tree, test5Tree, treeData, previewMode]);

  // Function to get a deterministic image for each node (fallback)
  const getNodeImage = useCallback((nodeId: string): string => {
    // This is a fallback for non-mechanism nodes
    // Just return a default image path
    return '/mek-images/150px/000-000-000.webp';
  }, []);
  
  // Function to get a random event image for event nodes
  const getEventImage = useCallback((nodeId: string): string => {
    // Use node ID to deterministically select an event image
    let hash = 0;
    for (let i = 0; i < nodeId.length; i++) {
      hash = ((hash << 5) - hash) + nodeId.charCodeAt(i);
      hash = hash & hash; // Convert to 32bit integer
    }
    // There are 154 event images (blank resize.webp and blank resize_2.webp through blank resize_154.webp)
    const totalEventImages = 154;
    const index = Math.abs(hash) % totalEventImages;
    
    // Return the correct filename
    if (index === 0) {
      return 'blank resize.webp';
    } else {
      return `blank resize_${index + 1}.webp`;
    }
  }, []);

  // Load images for nodes and wait for them to load
  useEffect(() => {
    // Skip image loading in preview mode
    if (!treeData || previewMode) return;

    const loadImages = async () => {
      const imageMap = new Map<string, HTMLImageElement>();
      const eventImageMap = new Map<string, HTMLImageElement>();
      const promises: Promise<void>[] = [];

      for (const node of treeData.nodes) {
        if (node.storyNodeType === 'final_boss') {
          // Use rainbow.jpg for final boss
          const img = new Image();
          const promise = new Promise<void>((resolve) => {
            img.onload = () => resolve();
            img.onerror = () => resolve(); // Still resolve on error to not block
          });
          img.src = '/random-images/rainbow.jpg';
          imageMap.set(node.id, img);
          promises.push(promise);
        } else if (node.storyNodeType === 'normal' || node.storyNodeType === 'boss') {
          // Load mek images for normal and boss nodes
          const imageName = getMekImage(node.id, false); // 150px for nodes
          const img = new Image();
          const promise = new Promise<void>((resolve) => {
            img.onload = () => resolve();
            img.onerror = () => resolve(); // Still resolve on error to not block
          });
          img.src = imageName; // Already has the full path from getMekImage
          imageMap.set(node.id, img);
          promises.push(promise);
        } else if (node.storyNodeType === 'event') {
          // Load event images for event nodes
          const eventImageName = getEventImage(node.id);
          const img = new Image();
          const promise = new Promise<void>((resolve) => {
            img.onload = () => resolve();
            img.onerror = () => resolve(); // Still resolve on error to not block
          });
          // Note: The path needs to match the actual folder structure with spaces encoded
          img.src = `/event-images/450px webp/${eventImageName.replace(/ /g, '%20')}`;
          eventImageMap.set(node.id, img);
          promises.push(promise);
        }
      }

      setNodeImages(imageMap);
      setEventImages(eventImageMap);
      await Promise.all(promises);
      setImagesLoaded(true);
    };

    loadImages();
    // Remove callback dependencies that cause loops - use stable dependencies instead
  }, [treeData?.nodes?.length, previewMode]);

  // Handle client-side mounting
  useEffect(() => {
    setMounted(true);
  }, []);

  // Calculate canvas size
  useEffect(() => {
    if (!mounted || !containerRef.current) return;
    
    const updateSize = () => {
      if (containerRef.current) {
        const container = containerRef.current;
        const width = container.clientWidth - 20; // Reduce width by 20px to move right edge left
        const height = Math.floor(width * 1.5); // 2:3 aspect ratio
        console.log("Canvas size updated:", { width, height });
        setCanvasSize({ width, height });
      }
    };
    
    updateSize(); // Call immediately
    setTimeout(updateSize, 100);
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, [mounted]);

  // Auto-scroll removed - users can now freely scroll up and down as they wish

  // Draw the tree on canvas
  useEffect(() => {
    console.log("Canvas draw effect:", {
      hasCanvas: !!canvasRef.current,
      hasTreeData: !!treeData,
      canvasWidth: canvasSize.width,
      canvasHeight: canvasSize.height,
      imagesLoaded: imagesLoaded
    });
    
    // Don't require images to be loaded - render without them if needed
    if (!canvasRef.current || !treeData || canvasSize.width === 0) {
      console.log("Canvas draw skipped - missing core requirements");
      return;
    }
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error("Failed to get canvas context");
      return;
    }

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Find bounds of all nodes
    // Adjust positions for event/boss nodes - they need to be centered
    const nodes = treeData.nodes.map(node => {
      const adjustedNode = { ...node };
      
      // Event and boss nodes need position adjustment to center them
      // Slightly less offset to move them toward upper-left
      if (node.storyNodeType === 'event') {
        // Event nodes: a bit less offset for upper-left positioning, plus 5px upward
        adjustedNode.x = node.x + 25; // Reduced from 30
        adjustedNode.y = node.y + 20; // Reduced by 5px more for upward shift
      } else if (node.storyNodeType === 'boss') {
        // Boss nodes: shifted 5px to the right
        adjustedNode.x = node.x + 40; // Increased by 5px for rightward shift
        adjustedNode.y = node.y + 35;
      } else if (node.storyNodeType === 'final_boss') {
        // Final boss: center it like START node (needs more rightward shift)
        adjustedNode.x = node.x + 75; // Increased to center like START
        adjustedNode.y = node.y + 20; // Move 40px higher up (reduced from 60)
      }
      // Normal nodes don't need adjustment
      
      return adjustedNode;
    });
    // Calculate bounds INCLUDING node sizes
    let actualMinX = Infinity, actualMaxX = -Infinity;
    let actualMinY = Infinity, actualMaxY = -Infinity;
    
    // Calculate the actual bounds including node sizes
    // MUST match the actual rendering sizes exactly (lines 565-590)
    nodes.forEach(node => {
      let nodeSize = 31.5; // normal nodes (5% larger)
      if (node.id === 'start') nodeSize = 75; // start node - MUST match line 571
      else if (node.storyNodeType === 'event') nodeSize = 67; // 12% bigger
      else if (node.storyNodeType === 'boss') nodeSize = 90; // boss nodes - MUST match line 581
      else if (node.storyNodeType === 'final_boss') nodeSize = 130; // final boss
      
      actualMinX = Math.min(actualMinX, node.x - nodeSize);
      actualMaxX = Math.max(actualMaxX, node.x + nodeSize);
      actualMinY = Math.min(actualMinY, node.y - nodeSize);
      actualMaxY = Math.max(actualMaxY, node.y + nodeSize);
    });
    
    const minX = Math.min(...nodes.map(n => n.x));
    const maxX = Math.max(...nodes.map(n => n.x));
    const minY = Math.min(...nodes.map(n => n.y));
    const maxY = Math.max(...nodes.map(n => n.y));
    
    // Find the start node position
    const startNode = nodes.find(n => n.id === 'start');
    if (startNode) {
      console.log("Start node position:", { x: startNode.x, y: startNode.y });
      console.log("Tree bounds:", { minX, maxX, minY, maxY });
      console.log("Actual bounds with node sizes:", { actualMinX, actualMaxX, actualMinY, actualMaxY });
    }
    
    const treeWidth = maxX - minX;
    const treeHeight = maxY - minY;
    const actualTreeWidth = actualMaxX - actualMinX;
    
    // Calculate scale based on tree width, but we'll adjust positioning for centering
    const padding = 30; // Slightly more padding for safety
    const scaleX = (canvas.width - padding * 2) / treeWidth; // Scale based on node centers, not full width
    const scale = previewMode
      ? Math.min(
          (canvas.width - 100) / treeWidth,
          (canvas.height - 100) / treeHeight
        ) * 0.15  // Much smaller scale for preview to fit all nodes
      : scaleX * 0.77; // Original scale for normal mode
    
    // Calculate total tree height when scaled
    const scaledTreeHeight = treeHeight * scale;
    
    // Transform function - position tree for viewport
    const transform = (x: number, y: number) => {
      // Use the same scaling for both preview and normal modes
      const scaledX = (x - minX) * scale;
      const scaledY = (y - minY) * scale;

      // Center the START node horizontally in the canvas
      let offsetX;
      if (startNode) {
        // Calculate where the start node would be after scaling
        const startScaledX = (startNode.x - minX) * scale;
        // Center it by placing it at canvas.width / 2
        // Add a manual adjustment to compensate for visual centering
        const centerAdjustment = -55; // Shift LEFT another 10px to fit in canvas
        offsetX = (canvas.width / 2) - startScaledX + centerAdjustment;

        // Debug logging (only log once per render cycle)
        if (Math.random() > 0.99) {
          console.log("START centering debug:", {
            canvasWidth: canvas.width,
            canvasCenter: canvas.width / 2,
            startNodeX: startNode.x,
            minX: minX,
            startScaledX: startScaledX,
            offsetX: offsetX,
            centerAdjustment: centerAdjustment,
            finalStartX: startScaledX + offsetX
          });
        }
      } else {
        // Fallback to centering the whole tree if no start node
        const leftOverflow = (minX - actualMinX) * scale;
        offsetX = padding + leftOverflow;
      }
      
      // Position the start node near the bottom of the canvas
      let offsetY;
      if (previewMode) {
        // In preview mode, fit the whole tree in view
        const treeScale = Math.min(
          (canvas.width - 100) / treeWidth,
          (canvas.height - 100) / treeHeight
        ) * 0.8;
        offsetY = canvas.height - 50;
      } else if (startNode) {
        // Always position based on start node
        const startScaledY = (startNode.y - minY) * scale;
        // Put start node at the very bottom of the canvas
        // The hemisphere should sit flush with the bottom edge
        offsetY = canvas.height - startScaledY + viewportOffset + 240; // Move down to sit flush at bottom edge
      } else {
        // Fallback if no start node
        offsetY = canvas.height - scaledTreeHeight + viewportOffset - padding;
      }
      
      return {
        x: scaledX + offsetX + panOffset.x,
        y: scaledY + offsetY + panOffset.y
      };
    };
    
    // Only draw nodes and connections that are visible in viewport
    const isInViewport = (y: number) => {
      return y >= -100 && y <= canvas.height + 100;
    };
    
    // First pass: draw connections
    treeData.connections.forEach(conn => {
      const fromNode = nodes.find(n => n.id === conn.from);
      const toNode = nodes.find(n => n.id === conn.to);
      
      if (fromNode && toNode) {
        let from = transform(fromNode.x, fromNode.y);
        let to = transform(toNode.x, toNode.y);
        
        // Move all non-start nodes up by 45 pixels to match node positions
        if (fromNode.id !== 'start') {
          from.y -= 45;
        }
        if (toNode.id !== 'start') {
          to.y -= 45;
        }
        
        // Adjust connection points for event nodes since they're offset
        if (fromNode.storyNodeType === 'event') {
          from.x -= 7;
          from.y -= 3;
        }
        if (toNode.storyNodeType === 'event') {
          to.x -= 7;
          to.y -= 3;
        }
        
        // Only draw if at least one end is visible
        if (isInViewport(from.y) || isInViewport(to.y)) {
          // Check connection status
          const fromCompleted = completedNodes.has(fromNode.id);
          const toCompleted = completedNodes.has(toNode.id);
          const isAvailablePath = (fromCompleted && !toCompleted) || (toCompleted && !fromCompleted);
          
          ctx.save();
          if (isAvailablePath) {
            // Glowing connection to available nodes
            const glowIntensity = 0.5 + Math.sin(Date.now() / 500) * 0.3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = `rgba(250, 182, 23, ${glowIntensity})`;
            ctx.strokeStyle = '#fab617';
            ctx.lineWidth = 4; // Increased by 1
          } else if (fromCompleted && toCompleted) {
            // Completed connection - green with subtle glow
            ctx.shadowBlur = 8;
            ctx.shadowColor = 'rgba(16, 185, 129, 0.5)';
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 3; // Increased by 1
          } else {
            // Unavailable connection
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#4b5563';
            ctx.lineWidth = 2; // Increased by 1
          }
          
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          ctx.stroke();
          ctx.restore();
        }
      }
    });
    
    // Second pass: draw nodes
    console.log(`Drawing ${nodes.length} nodes`);
    nodes.forEach((node, index) => {
      // Transform node position
      let pos = transform(node.x, node.y);
      
      // Move all non-start nodes up by 45 pixels
      if (node.id !== 'start') {
        pos.y -= 45;
      }
      
      // Special positioning for event nodes - move 7px left and 3px up
      if (node.storyNodeType === 'event') {
        pos.x -= 7;
        pos.y -= 3;
      }
      
      // REMOVED - Don't move nodes from their saved positions
      // The spacing is handled by moving the entire tree down
      
      // Log START node position specifically
      if (node.id === 'start') {
        console.log(`START node transformed position: (${pos.x}, ${pos.y}), canvas height: ${canvas.height}`);
      }
      
      // Skip nodes outside viewport
      if (!isInViewport(pos.y)) {
        if (index < 5 || node.id === 'start') console.log(`Node ${node.id} skipped - outside viewport at y=${pos.y}`);
        return;
      }
      
      if (index < 5 || node.id === 'start') console.log(`Drawing node ${node.id} at (${pos.x}, ${pos.y})`)
      
      // Check if node is completed
      const isCompleted = completedNodes.has(node.id);
      
      // Set node sizes - make all nodes bigger
      let nodeSize = 31.5; // normal nodes (5% larger) (was 28)
      let fillColor = 'transparent'; // No fill for normal nodes
      let strokeColor = '#6b7280'; // gray for unavailable
      let strokeWidth = 2; // thin stroke
      
      if (node.id === 'start') {
        nodeSize = 75; // start node - 25% bigger for hemisphere effect
        fillColor = '#fab617'; // yellow
        strokeColor = '#000000';
        strokeWidth = 3;
      } else if (node.storyNodeType === 'event') {
        nodeSize = 67; // Event nodes - 12% bigger (was 60)
        fillColor = '#2e1f3e'; // Very dark, desaturated purple (will be updated if available)
        strokeColor = '#6b7280'; // Will be updated after isAvailable is calculated
        strokeWidth = 2;
      } else if (node.storyNodeType === 'boss') {
        nodeSize = 90; // Boss nodes - 12% bigger (was 80, then 88, now +2%)
        fillColor = 'transparent'; // Will use custom rendering
        strokeColor = '#6b7280'; // Will be updated after isAvailable is calculated
        strokeWidth = 2;
      } else if (node.storyNodeType === 'final_boss') {
        nodeSize = 130; // Final boss - 30% bigger (was 100)
        fillColor = 'transparent'; // Will use custom rendering
        strokeColor = '#6b7280'; // Will be updated after isAvailable is calculated
        strokeWidth = 2;
      }
      
      // Check if node is available (connected to a completed node)
      // Start node should never be "available" - it's the starting point
      // Only allow upward progression (target node must have lower Y value than completed nodes)
      const isAvailable = node.id !== 'start' && !isCompleted && treeData.connections.some(conn => {
        const otherNodeId = conn.from === node.id ? conn.to : (conn.to === node.id ? conn.from : null);
        if (!otherNodeId || !completedNodes.has(otherNodeId)) return false;
        
        // Find the Y value of the connected completed node
        const connectedNode = nodes.find(n => n.id === otherNodeId);
        if (!connectedNode) return false;
        
        // Only allow progression if target node is higher on screen (lower Y value)
        return node.y < connectedNode.y;
      });
      
      // Update stroke color and width based on availability for non-mechanism nodes
      if (node.id !== 'start' && node.storyNodeType !== 'normal') {
        strokeColor = isCompleted ? '#10b981' : (isAvailable ? '#fab617' : '#6b7280');
        strokeWidth = isAvailable ? 3 : 2;
        if (node.storyNodeType === 'final_boss' && isAvailable) {
          strokeWidth = 4; // Thicker stroke for final boss
        }
        // Update event node fill color based on availability
        if (node.storyNodeType === 'event') {
          fillColor = isAvailable ? '#8b5cf6' : '#2e1f3e'; // Lighter purple when available, very dark desaturated when not
        }
      }
      
      // Draw subtle glow for available nodes (all types)
      if (isAvailable && node.id !== 'start') {
        // Enhanced glow for hovered node - fixed to compare IDs properly
        const isHovered = hoveredNode && hoveredNode.id === node.id;
        
        // Debug logging for hover detection
        if (node.id === 'node-1' || node.id === 'node-2' || node.id === 'node-3') {
          if (hoveredNode) {
            console.log(`Node ${node.id}: hoveredNode.id=${hoveredNode.id}, isHovered=${isHovered}`);
          }
        }

        // Apply pulse glow hover effect
        if (isHovered) {
          // Pulse Glow effect only
          ctx.save();
          const pulseIntensity = 0.6 + Math.sin(Date.now() / 300) * 0.4;
          ctx.shadowBlur = 40;
          ctx.shadowColor = `rgba(250, 182, 23, ${pulseIntensity})`;
          // Double glow effect
          for (let i = 0; i < 2; i++) {
            if (node.storyNodeType === 'event' || node.storyNodeType === 'normal') {
              ctx.beginPath();
              ctx.arc(pos.x, pos.y, nodeSize + i * 5, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(250, 182, 23, ${pulseIntensity * (1 - i * 0.3)})`;
              ctx.lineWidth = 2;
              ctx.stroke();
            } else {
              ctx.strokeStyle = `rgba(250, 182, 23, ${pulseIntensity * (1 - i * 0.3)})`;
              ctx.lineWidth = 2;
              ctx.strokeRect(pos.x - nodeSize - i * 5, pos.y - nodeSize - i * 5, (nodeSize + i * 5) * 2, (nodeSize + i * 5) * 2);
            }
          }
          ctx.restore();
        }

        // Base glow for available nodes (always present)
        ctx.save();
        const baseGlowIntensity = 0.2 + Math.sin(Date.now() / 800) * 0.1;
        ctx.shadowBlur = 25;
        ctx.shadowColor = `rgba(255, 255, 255, ${baseGlowIntensity})`;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Draw shape for white backglow
        if (node.storyNodeType === 'event' || node.storyNodeType === 'normal') {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, nodeSize - 5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.fill();
        } else {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.fillRect(pos.x - nodeSize + 5, pos.y - nodeSize + 5, (nodeSize - 5) * 2, (nodeSize - 5) * 2);
        }
        ctx.restore();
        
        // Yellow glow on top (base level)
        ctx.save();
        const glowIntensity = 0.3 + Math.sin(Date.now() / 800) * 0.2;
        ctx.shadowBlur = 15;
        ctx.shadowColor = `rgba(250, 182, 23, ${glowIntensity})`;
        
        // Draw shape for glow
        if (node.storyNodeType === 'event') {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
          ctx.strokeStyle = 'transparent';
          ctx.stroke();
        } else if (node.storyNodeType === 'normal') {
          const isChallenger = (node as any).challenger === true;
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
          // Enhanced glow for Challenger nodes
          if (isChallenger) {
            ctx.shadowColor = `rgba(255, 100, 50, ${glowIntensity * 1.5})`;
            ctx.shadowBlur = 25;
          }
          ctx.strokeStyle = 'transparent';
          ctx.stroke();
        } else {
          ctx.strokeStyle = 'transparent';
          ctx.strokeRect(pos.x - nodeSize, pos.y - nodeSize, nodeSize * 2, nodeSize * 2);
        }
        ctx.restore();
      } else if ((isAvailable || isCompleted) && node.storyNodeType !== 'normal' && node.id !== 'start') {
        ctx.save();
        if (isAvailable) {
          const glowIntensity = 0.5 + Math.sin(Date.now() / 500) * 0.3;
          ctx.shadowBlur = 20;
          ctx.shadowColor = `rgba(250, 182, 23, ${glowIntensity})`;
        } else if (isCompleted) {
          ctx.shadowBlur = 15;
          ctx.shadowColor = 'rgba(16, 185, 129, 0.6)';
        }
        
        // Draw glow shape
        if (node.storyNodeType === 'event') {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
          ctx.fillStyle = 'transparent';
          ctx.strokeStyle = isCompleted ? '#10b981' : '#fab617';
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
        } else {
          ctx.strokeStyle = isCompleted ? '#10b981' : '#fab617';
          ctx.lineWidth = strokeWidth;
          ctx.strokeRect(pos.x - nodeSize, pos.y - nodeSize, nodeSize * 2, nodeSize * 2);
        }
        ctx.restore();
      }
      
      // Draw minimal shadow
      ctx.shadowBlur = 0;
      ctx.shadowColor = 'transparent';
      
      // Draw node shape based on type
      if (node.storyNodeType === 'event') {
        // Events are circles (matching builder)
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
        
        // Draw event image if available
        if (eventImages.has(node.id)) {
          const img = eventImages.get(node.id)!;
          if (img.complete && img.naturalWidth > 0) {
            ctx.save();
            // Clip to circular shape
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, nodeSize - 3, 0, Math.PI * 2); // Slightly smaller to leave room for border
            ctx.clip();
            
            // Draw the event image centered and cropped (not squashed)
            // Use the image at its full height, center-cropped into circle
            const imgAspect = img.width / img.height;
            const circleSize = (nodeSize - 3) * 2;
            
            // Calculate source dimensions to maintain aspect ratio
            let srcWidth = img.width;
            let srcHeight = img.height;
            let srcX = 0;
            let srcY = 0;
            
            // If image is wider than tall, crop the sides
            if (imgAspect > 1) {
              srcWidth = img.height; // Make it square by using height
              srcX = (img.width - srcWidth) / 2; // Center horizontally
            } else if (imgAspect < 1) {
              // If image is taller than wide, crop top/bottom
              srcHeight = img.width; // Make it square by using width
              srcY = (img.height - srcHeight) / 2; // Center vertically
            }
            
            // Draw the image cropped and centered
            ctx.drawImage(img, srcX, srcY, srcWidth, srcHeight,
                         pos.x - nodeSize + 3, pos.y - nodeSize + 3, circleSize, circleSize);
            
            // Add overlay effects based on state
            if (!isCompleted && !isAvailable) {
              // Darken unavailable nodes
              ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
              ctx.arc(pos.x, pos.y, nodeSize - 3, 0, Math.PI * 2);
              ctx.fill();
            } else if (isCompleted) {
              // Green tint for completed
              ctx.fillStyle = 'rgba(16, 185, 129, 0.3)';
              ctx.arc(pos.x, pos.y, nodeSize - 3, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }
        }
        
        // Draw border with adjusted colors for availability
        ctx.strokeStyle = isCompleted ? '#10b981' : 
                         isAvailable ? '#fab617' : 
                         '#3f3f46'; // Much darker gray when unavailable
        ctx.lineWidth = isAvailable ? 2 : 1; // Thinner when not available
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
        ctx.stroke();
      } else if (node.storyNodeType === 'boss') {
        // DESIGN OPTION 1: Holographic Energy Shield
        const halfSize = nodeSize;
        const time = Date.now() / 1000;
        
        // Draw dark metallic base
        ctx.fillStyle = 'rgba(10, 10, 20, 0.9)';
        ctx.fillRect(pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
        
        // Draw energy field layers
        for (let i = 3; i >= 0; i--) {
          const offset = i * 3;
          const alpha = 0.15 - (i * 0.03);
          
          // Animated energy field
          ctx.save();
          ctx.strokeStyle = isCompleted ? `rgba(16, 185, 129, ${alpha})` : 
                           isAvailable ? `rgba(239, 68, 68, ${alpha + Math.sin(time * 2) * 0.1})` : 
                           `rgba(107, 114, 128, ${alpha})`;
          ctx.lineWidth = 1;
          ctx.setLineDash([10, 5]);
          ctx.lineDashOffset = time * 10;
          ctx.strokeRect(pos.x - halfSize - offset, pos.y - halfSize - offset, 
                        (halfSize + offset) * 2, (halfSize + offset) * 2);
          ctx.restore();
        }
        
        // Draw corner energy nodes
        const corners = [
          { x: pos.x - halfSize, y: pos.y - halfSize },
          { x: pos.x + halfSize, y: pos.y - halfSize },
          { x: pos.x + halfSize, y: pos.y + halfSize },
          { x: pos.x - halfSize, y: pos.y + halfSize }
        ];
        
        corners.forEach((corner, i) => {
          const pulse = Math.sin(time * 3 + i) * 0.5 + 0.5;
          ctx.save();
          ctx.shadowBlur = 10;
          ctx.shadowColor = isCompleted ? 'rgba(16, 185, 129, 0.8)' :
                           isAvailable ? `rgba(250, 182, 23, ${0.5 + pulse * 0.5})` : // Yellow glow for available
                           'rgba(107, 114, 128, 0.3)';
          ctx.fillStyle = isCompleted ? '#10b981' :
                         isAvailable ? '#fab617' :
                         '#6b7280';
          ctx.beginPath();
          ctx.arc(corner.x, corner.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
        
        // Draw tech pattern overlay
        ctx.save();
        ctx.globalAlpha = 0.2;
        ctx.strokeStyle = isCompleted ? '#10b981' : isAvailable ? '#ef4444' : '#6b7280';
        ctx.lineWidth = 0.5;
        
        // Circuit-like patterns
        for (let i = 0; i < 3; i++) {
          const y = pos.y - halfSize + (halfSize * 2 / 3) * (i + 0.5);
          ctx.beginPath();
          ctx.moveTo(pos.x - halfSize + 10, y);
          ctx.lineTo(pos.x + halfSize - 10, y);
          ctx.stroke();
        }
        ctx.restore();
        
        // Inner border with energy glow
        ctx.save();
        if (isAvailable) {
          ctx.shadowBlur = 15;
          ctx.shadowColor = 'rgba(250, 182, 23, 0.6)'; // Yellow shadow for available
        }
        ctx.strokeStyle = isCompleted ? '#10b981' :
                         isAvailable ? '#fab617' :
                         '#4b5563';
        ctx.lineWidth = isAvailable ? 2 : 1;
        ctx.strokeRect(pos.x - halfSize + 5, pos.y - halfSize + 5, 
                      halfSize * 2 - 10, halfSize * 2 - 10);
        ctx.restore();
        
        // Draw boss mech image
        if (nodeImages.has(node.id)) {
          const img = nodeImages.get(node.id)!;
          if (img.complete && img.naturalWidth > 0) {
            ctx.save();
            // Clip to inner rectangle
            ctx.beginPath();
            ctx.rect(pos.x - halfSize + 10, pos.y - halfSize + 10, 
                    halfSize * 2 - 20, halfSize * 2 - 20);
            ctx.clip();
            
            // Draw image
            ctx.globalAlpha = isCompleted ? 1 : isAvailable ? 0.9 : 0.4;
            ctx.drawImage(img, pos.x - halfSize + 10, pos.y - halfSize + 10, 
                         halfSize * 2 - 20, halfSize * 2 - 20);
            
            // Add color overlay
            if (isCompleted) {
              ctx.fillStyle = 'rgba(16, 185, 129, 0.3)';
              ctx.fillRect(pos.x - halfSize + 10, pos.y - halfSize + 10, 
                          halfSize * 2 - 20, halfSize * 2 - 20);
            } else if (!isAvailable) {
              ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
              ctx.fillRect(pos.x - halfSize + 10, pos.y - halfSize + 10, 
                          halfSize * 2 - 20, halfSize * 2 - 20);
            }
            ctx.restore();
          }
        }
        
      } else if (node.storyNodeType === 'final_boss') {
        // Epic Final Boss with Electrical Effects
        const halfSize = nodeSize;
        const time = Date.now() / 1000;
        
        // Draw dark metallic base (similar to mini-boss)
        ctx.fillStyle = 'rgba(10, 10, 20, 0.95)';
        ctx.fillRect(pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
        
        // Draw multiple energy field layers (more intense than mini-boss)
        for (let i = 5; i >= 0; i--) {
          const offset = i * 4;
          const alpha = 0.2 - (i * 0.03);
          
          // Animated energy field with electrical effect
          ctx.save();
          ctx.strokeStyle = isCompleted ? `rgba(16, 185, 129, ${alpha})` : 
                           isAvailable ? `rgba(250, 182, 23, ${alpha + Math.sin(time * 3) * 0.15})` : 
                           `rgba(107, 114, 128, ${alpha})`;
          ctx.lineWidth = 2 - (i * 0.2);
          ctx.setLineDash([15, 8]);
          ctx.lineDashOffset = time * 15;
          ctx.strokeRect(pos.x - halfSize - offset, pos.y - halfSize - offset, 
                        (halfSize + offset) * 2, (halfSize + offset) * 2);
          ctx.restore();
        }
        
        // Draw electrical arcs from corners
        ctx.save();
        ctx.strokeStyle = isCompleted ? 'rgba(16, 185, 129, 0.6)' :
                         isAvailable ? 'rgba(250, 182, 23, 0.8)' :
                         'rgba(107, 114, 128, 0.3)';
        ctx.lineWidth = 2;
        ctx.globalAlpha = Math.random() > 0.3 ? 1 : 0; // Flickering effect
        
        // Random electrical arcs
        for (let i = 0; i < 4; i++) {
          if (Math.random() > 0.5) {
            ctx.beginPath();
            const startAngle = (i * Math.PI / 2) + time;
            const startX = pos.x + Math.cos(startAngle) * halfSize * 1.2;
            const startY = pos.y + Math.sin(startAngle) * halfSize * 1.2;
            
            // Create jagged lightning path
            ctx.moveTo(startX, startY);
            const steps = 5;
            for (let j = 1; j <= steps; j++) {
              const progress = j / steps;
              const endX = pos.x + (startX - pos.x) * (1 - progress);
              const endY = pos.y + (startY - pos.y) * (1 - progress);
              const offsetX = (Math.random() - 0.5) * 20;
              const offsetY = (Math.random() - 0.5) * 20;
              ctx.lineTo(endX + offsetX, endY + offsetY);
            }
            ctx.stroke();
          }
        }
        ctx.restore();
        
        // Draw corner energy nodes (larger and more intense than mini-boss)
        const corners = [
          { x: pos.x - halfSize, y: pos.y - halfSize },
          { x: pos.x + halfSize, y: pos.y - halfSize },
          { x: pos.x + halfSize, y: pos.y + halfSize },
          { x: pos.x - halfSize, y: pos.y + halfSize }
        ];
        
        corners.forEach((corner, i) => {
          const pulse = Math.sin(time * 4 + i) * 0.5 + 0.5;
          ctx.save();
          ctx.shadowBlur = 20;
          ctx.shadowColor = isCompleted ? 'rgba(16, 185, 129, 1)' :
                           isAvailable ? `rgba(250, 182, 23, ${0.7 + pulse * 0.3})` :
                           'rgba(107, 114, 128, 0.4)';
          ctx.fillStyle = isCompleted ? '#10b981' :
                         isAvailable ? '#fab617' :
                         '#6b7280';
          ctx.beginPath();
          ctx.arc(corner.x, corner.y, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
        
        // Draw tech pattern overlay (more complex than mini-boss)
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = isCompleted ? '#10b981' : isAvailable ? '#fab617' : '#6b7280';
        ctx.lineWidth = 1;
        
        // Circuit patterns
        for (let i = 0; i < 5; i++) {
          const y = pos.y - halfSize + (halfSize * 2 / 5) * (i + 0.5);
          ctx.beginPath();
          ctx.moveTo(pos.x - halfSize + 15, y);
          ctx.lineTo(pos.x + halfSize - 15, y);
          ctx.stroke();
          
          // Add vertical connections
          if (i < 4) {
            const x = pos.x - halfSize * 0.5 + Math.random() * halfSize;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + (halfSize * 2 / 5));
            ctx.stroke();
          }
        }
        ctx.restore();
        
        // Draw final boss image (rainbow.jpg)
        if (nodeImages.has(node.id)) {
          const img = nodeImages.get(node.id)!;
          if (img.complete && img.naturalWidth > 0) {
            ctx.save();
            // Clip to inner rectangle
            ctx.beginPath();
            ctx.rect(pos.x - halfSize + 15, pos.y - halfSize + 15, 
                    halfSize * 2 - 30, halfSize * 2 - 30);
            ctx.clip();
            
            // Draw image
            ctx.globalAlpha = isCompleted ? 1 : isAvailable ? 0.95 : 0.3;
            ctx.drawImage(img, pos.x - halfSize + 15, pos.y - halfSize + 15, 
                         halfSize * 2 - 30, halfSize * 2 - 30);
            
            // Add color overlay
            if (isCompleted) {
              ctx.fillStyle = 'rgba(16, 185, 129, 0.25)';
              ctx.fillRect(pos.x - halfSize + 15, pos.y - halfSize + 15, 
                          halfSize * 2 - 30, halfSize * 2 - 30);
            } else if (!isAvailable) {
              ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
              ctx.fillRect(pos.x - halfSize + 15, pos.y - halfSize + 15, 
                          halfSize * 2 - 30, halfSize * 2 - 30);
            }
            ctx.restore();
          }
        }
        
        // Inner border with intense glow
        ctx.save();
        if (isAvailable) {
          ctx.shadowBlur = 25;
          ctx.shadowColor = 'rgba(250, 182, 23, 0.8)';
        } else if (isCompleted) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = 'rgba(16, 185, 129, 0.7)';
        }
        ctx.strokeStyle = isCompleted ? '#10b981' :
                         isAvailable ? '#fab617' :
                         '#4b5563';
        ctx.lineWidth = isAvailable ? 3 : 2;
        ctx.strokeRect(pos.x - halfSize + 8, pos.y - halfSize + 8, 
                      halfSize * 2 - 16, halfSize * 2 - 16);
        ctx.restore();
        
      } else if (node.id === 'start') {
        // Draw special hemisphere start node - CORRECT ORIENTATION
        ctx.save();
        
        const hemisphereRadius = nodeSize; // 25% larger size
        
        // Draw hemisphere with flat side DOWN (arc from 0 to PI goes top half)
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, hemisphereRadius, 0, Math.PI, true);
        ctx.closePath();
        
        // Industrial gradient fill with radial effect
        const gradient = ctx.createRadialGradient(pos.x, pos.y - hemisphereRadius/3, 0, pos.x, pos.y, hemisphereRadius);
        gradient.addColorStop(0, '#fbbf24');
        gradient.addColorStop(0.3, '#fab617');
        gradient.addColorStop(0.7, '#f59e0b');
        gradient.addColorStop(1, '#d97706');
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Add industrial metallic overlay
        ctx.save();
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, hemisphereRadius, 0, Math.PI, true);
        ctx.closePath();
        ctx.clip();
        
        // Add metallic sheen effect
        const sheenGradient = ctx.createLinearGradient(pos.x - hemisphereRadius, pos.y - hemisphereRadius, pos.x + hemisphereRadius, pos.y);
        sheenGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
        sheenGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.15)');
        sheenGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.25)');
        sheenGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.1)');
        sheenGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = sheenGradient;
        ctx.fillRect(pos.x - hemisphereRadius, pos.y - hemisphereRadius, hemisphereRadius * 2, hemisphereRadius);
        
        // Add improved industrial pattern
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.12)';
        ctx.lineWidth = 1;
        
        // Concentric arcs
        for (let r = 15; r < hemisphereRadius; r += 15) {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, r, 0, Math.PI, true);
          ctx.stroke();
        }
        
        // Radial lines
        for (let angle = 0; angle < Math.PI; angle += Math.PI / 12) {
          ctx.beginPath();
          ctx.moveTo(pos.x, pos.y);
          ctx.lineTo(pos.x + Math.cos(angle) * hemisphereRadius, pos.y - Math.sin(angle) * hemisphereRadius);
          ctx.stroke();
        }
        
        // Add subtle dots at intersections
        ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
        for (let r = 30; r < hemisphereRadius; r += 30) {
          for (let angle = Math.PI / 12; angle < Math.PI; angle += Math.PI / 12) {
            ctx.beginPath();
            ctx.arc(pos.x + Math.cos(angle) * r, pos.y - Math.sin(angle) * r, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        ctx.restore();
        
        // Black border
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, hemisphereRadius, 0, Math.PI, true);
        ctx.closePath();
        ctx.stroke();
        
        // Add bottom edge highlight (flat part)
        ctx.strokeStyle = 'rgba(250, 182, 23, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(pos.x - hemisphereRadius, pos.y);
        ctx.lineTo(pos.x + hemisphereRadius, pos.y);
        ctx.stroke();
        
        ctx.restore();
      } else {
        // All others are squares (normal, boss, final boss)
        const halfSize = nodeSize;
        
        // Draw background only for non-normal nodes
        if (node.storyNodeType !== 'normal') {
          ctx.fillStyle = fillColor;
          ctx.fillRect(pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
        }
        
        // Draw mechanism image for normal nodes (but NOT the start node)
        if (node.storyNodeType === 'normal' && node.id !== 'start' && nodeImages.has(node.id)) {
          const img = nodeImages.get(node.id)!;
          if (img.complete && img.naturalWidth > 0) { // Check image is loaded and not broken
            ctx.save();
            // Draw circular frame for mechanism nodes
            const isChallenger = (node as any).challenger === true;
            
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, halfSize, 0, Math.PI * 2);
            
            // Background color - darker for Challenger nodes
            if (isChallenger) {
              ctx.fillStyle = 'rgba(40, 15, 15, 0.9)'; // Dark red/brown background
            } else {
              ctx.fillStyle = 'rgba(20, 20, 30, 0.8)';
            }
            ctx.fill();
            
            // Border styling with Challenger-specific colors
            let borderColor;
            let borderWidth;
            
            if (isChallenger) {
              // Challenger nodes: style-specific colors with pulsing effect
              const challengerPulse = 0.6 + Math.sin(Date.now() / 400) * 0.4;
              if (isCompleted) {
                borderColor = `rgba(16, 185, 129, ${challengerPulse})`; // Still green when completed
                borderWidth = 3;
              } else if (isAvailable) {
                borderColor = `rgba(255, 100, 50, ${challengerPulse})`; // Pulsing orange-red
                borderWidth = 3;
              } else {
                borderColor = `rgba(140, 40, 40, ${challengerPulse * 0.7})`; // Darker red pulse
                borderWidth = 2;
              }
            } else {
              // Normal node colors
              borderColor = isCompleted ? 'rgba(16, 185, 129, 0.8)' : 
                           isAvailable ? 'rgba(250, 182, 23, 0.9)' : 
                           'rgba(60, 60, 80, 0.6)';
              borderWidth = isCompleted ? 2 : isAvailable ? 2 : 1;
            }
            
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderWidth;
            ctx.stroke();
            
            // Add extra glow effect for Challenger nodes
            if (isChallenger && (isAvailable || isCompleted)) {
              ctx.save();
              const glowIntensity = 0.4 + Math.sin(Date.now() / 350) * 0.3;
              ctx.shadowBlur = 25;
              
              // Glow color based on completion
              if (isCompleted) {
                ctx.shadowColor = 'rgba(16, 185, 129, 0.6)';
              } else {
                ctx.shadowColor = 'rgba(255, 100, 50, 0.6)'; // Orange-red glow
              }
              
              ctx.beginPath();
              ctx.arc(pos.x, pos.y, halfSize + 5, 0, Math.PI * 2);
              ctx.strokeStyle = 'transparent';
              ctx.stroke();
              ctx.restore();
            }
            
            // Clip to circular shape (slightly smaller for frame effect)
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, halfSize - 2, 0, Math.PI * 2);
            ctx.clip();
            
            // Apply hover effect to image
            const isHovered = hoveredNode && hoveredNode.id === node.id;
            if (isHovered) {
              ctx.save();
              // Scale effect on hover
              const hoverScale = 1.05 + Math.sin(Date.now() / 300) * 0.02; // Subtle pulse
              const scaledSize = halfSize * hoverScale;
              // Brightness effect
              ctx.filter = 'brightness(1.2) contrast(1.1)';
              ctx.drawImage(img, pos.x - scaledSize, pos.y - scaledSize, scaledSize * 2, scaledSize * 2);
              ctx.filter = 'none';
              ctx.restore();
            } else if (isChallenger && !isCompleted) {
              // Apply selected challenger effect
              ctx.save();
              
              // Create unique offset for each node based on its ID
              let nodeHash = 0;
              for (let i = 0; i < node.id.length; i++) {
                nodeHash = ((nodeHash << 5) - nodeHash) + node.id.charCodeAt(i);
              }
              const nodeOffset = (Math.abs(nodeHash) % 1000) / 100; // Unique offset 0-10
              const time = Date.now() + nodeOffset * 1000; // Add node-specific time offset
              
              switch (challengerEffect) {
                case 'quantum1': // Ripple Wave effect
                  // Draw base blurred image
                  ctx.filter = 'blur(2px) brightness(0.7) contrast(1.2)';
                  ctx.drawImage(img, pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
                  ctx.filter = 'none';
                  
                  // Continuous ripple waves emanating from multiple points
                  ctx.globalCompositeOperation = 'screen';
                  const rippleCount = 5;
                  
                  for (let i = 0; i < rippleCount; i++) {
                    // Use continuous sine/cosine for seamless motion
                    const rippleTime = time * 0.0008 + i * 2.4 + nodeOffset * 0.7;
                    const centerX = pos.x + Math.sin(rippleTime * 1.3) * halfSize * 0.5;
                    const centerY = pos.y + Math.cos(rippleTime * 0.9) * halfSize * 0.5;
                    
                    // Multiple expanding rings per ripple source
                    for (let ring = 0; ring < 3; ring++) {
                      const ringTime = time * 0.001 + ring * 0.8;
                      const radius = ((ringTime * 30) % (halfSize * 2)) + 10;
                      const alpha = Math.max(0, 1 - (radius / (halfSize * 2))) * 0.3;
                      
                      const gradient = ctx.createRadialGradient(
                        centerX, centerY, Math.max(0, radius - 10),
                        centerX, centerY, radius
                      );
                      gradient.addColorStop(0, 'rgba(0, 255, 255, 0)');
                      gradient.addColorStop(0.5, `rgba(0, 255, 255, ${alpha})`);
                      gradient.addColorStop(0.8, `rgba(255, 0, 255, ${alpha * 0.5})`);
                      gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                      
                      ctx.fillStyle = gradient;
                      ctx.fillRect(pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
                    }
                  }
                  
                  // Subtle wave distortion
                  ctx.globalCompositeOperation = 'difference';
                  ctx.globalAlpha = 0.2;
                  for (let y = 0; y < halfSize * 2; y += 6) {
                    const waveOffset = Math.sin(time * 0.001 + y * 0.05) * 3;
                    ctx.drawImage(
                      img,
                      pos.x - halfSize, pos.y - halfSize + y,
                      halfSize * 2, 6,
                      pos.x - halfSize + waveOffset, pos.y - halfSize + y,
                      halfSize * 2, 6
                    );
                  }
                  break;
                  
                case 'quantum2': // Phase Shift effect
                  // Draw base blurred image
                  ctx.filter = 'blur(2px) brightness(0.7) contrast(1.2)';
                  ctx.drawImage(img, pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
                  ctx.filter = 'none';
                  
                  // Phasing layers - image shifts between dimensions
                  ctx.globalCompositeOperation = 'screen';
                  const phaseCount = 4;
                  
                  for (let p = 0; p < phaseCount; p++) {
                    const phaseTime = time * 0.0006 + p * Math.PI * 0.5 + nodeOffset;
                    const phaseAlpha = (Math.sin(phaseTime) + 1) * 0.35;
                    const phaseX = Math.sin(phaseTime * 1.7) * 8;
                    const phaseY = Math.cos(phaseTime * 1.3) * 8;
                    
                    ctx.globalAlpha = phaseAlpha;
                    
                    // Draw phase-shifted copies with color tints
                    ctx.save();
                    if (p % 2 === 0) {
                      ctx.filter = 'hue-rotate(180deg)';
                    } else {
                      ctx.filter = 'hue-rotate(-60deg)';
                    }
                    ctx.drawImage(
                      img,
                      pos.x - halfSize + phaseX,
                      pos.y - halfSize + phaseY,
                      halfSize * 2, halfSize * 2
                    );
                    ctx.restore();
                  }
                  
                  // Quantum interference pattern
                  ctx.globalCompositeOperation = 'overlay';
                  ctx.globalAlpha = 0.3;
                  const interferenceTime = time * 0.0008;
                  
                  for (let x = 0; x < halfSize * 2; x += 4) {
                    for (let y = 0; y < halfSize * 2; y += 4) {
                      const dist1 = Math.sqrt(Math.pow(x - halfSize * 0.3, 2) + Math.pow(y - halfSize * 0.3, 2));
                      const dist2 = Math.sqrt(Math.pow(x - halfSize * 1.7, 2) + Math.pow(y - halfSize * 1.7, 2));
                      const interference = Math.sin(dist1 * 0.1 - interferenceTime) * Math.sin(dist2 * 0.1 + interferenceTime);
                      
                      if (interference > 0.5) {
                        const brightness = interference * 255;
                        ctx.fillStyle = `rgba(0, ${brightness}, ${brightness}, 0.5)`;
                        ctx.fillRect(pos.x - halfSize + x, pos.y - halfSize + y, 4, 4);
                      }
                    }
                  }
                  break;
                  
                case 'quantum3': // Dimensional Tear effect
                  // Draw base blurred image
                  ctx.filter = 'blur(2px) brightness(0.7) contrast(1.2)';
                  ctx.drawImage(img, pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
                  ctx.filter = 'none';
                  
                  // Dimensional tears - vertical rifts
                  ctx.globalCompositeOperation = 'screen';
                  for (let i = 0; i < 4; i++) {
                    const tearTime = time * 0.0005 + i * 1.7 + nodeOffset;
                    const tearX = pos.x + Math.sin(tearTime) * halfSize * 0.8;
                    const tearY = pos.y + Math.cos(tearTime * 0.7) * halfSize * 0.3;
                    
                    // Create vertical tear gradient
                    const tearGradient = ctx.createLinearGradient(
                      tearX - 2, tearY - halfSize,
                      tearX + 2, tearY - halfSize
                    );
                    tearGradient.addColorStop(0, 'rgba(255, 0, 255, 0)');
                    tearGradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.8)');
                    tearGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                    
                    ctx.fillStyle = tearGradient;
                    const tearHeight = halfSize * 1.5 + Math.sin(tearTime * 3) * halfSize * 0.3;
                    ctx.fillRect(tearX - 2, tearY - tearHeight/2, 4, tearHeight);
                  }
                  
                  // Reality distortion waves
                  ctx.globalCompositeOperation = 'difference';
                  ctx.globalAlpha = 0.4;
                  const waveCount = 3;
                  for (let w = 0; w < waveCount; w++) {
                    const waveTime = time * 0.001 + w * 2.1 + nodeOffset * 0.5;
                    const waveRadius = (Math.sin(waveTime) + 1) * halfSize;
                    
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, waveRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 0, 255, ${0.3 - w * 0.1})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                  }
                  
                  // Pixel displacement effect
                  ctx.globalCompositeOperation = 'source-over';
                  ctx.globalAlpha = 0.6;
                  const gridSize = 8;
                  for (let gx = 0; gx < halfSize * 2; gx += gridSize) {
                    for (let gy = 0; gy < halfSize * 2; gy += gridSize) {
                      const distortTime = time * 0.002 + (gx + gy) * 0.01;
                      if (Math.sin(distortTime) > 0.7) {
                        const offsetX = Math.sin(distortTime * 2) * 3;
                        const offsetY = Math.cos(distortTime * 2) * 3;
                        
                        ctx.drawImage(
                          img,
                          pos.x - halfSize + gx, pos.y - halfSize + gy,
                          gridSize, gridSize,
                          pos.x - halfSize + gx + offsetX, pos.y - halfSize + gy + offsetY,
                          gridSize, gridSize
                        );
                      }
                    }
                  }
                  break;
              }
              
              ctx.globalAlpha = 1;
              ctx.globalCompositeOperation = 'source-over';
              ctx.restore();
            } else {
              // Draw image at full opacity always
              ctx.drawImage(img, pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
            }
            
            // Draw darkening overlay for unavailable/non-completed nodes
            if (!isCompleted && !isAvailable) {
              ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
              ctx.fillRect(pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
            }
            // Draw green overlay for completed nodes
            else if (isCompleted) {
              ctx.fillStyle = 'rgba(16, 185, 129, 0.2)';
              ctx.fillRect(pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
            }
            
            // Add green glow effect for completed mechanism nodes
            if (isCompleted) {
              ctx.save();
              ctx.shadowBlur = 10;
              ctx.shadowColor = 'rgba(16, 185, 129, 0.6)';
              ctx.beginPath();
              ctx.arc(pos.x, pos.y, halfSize - 2, 0, Math.PI * 2);
              ctx.strokeStyle = 'rgba(16, 185, 129, 0.8)';
              ctx.lineWidth = 2;
              ctx.stroke();
              ctx.restore();
            }
            ctx.restore();
            
            // Add Challenger frame effects AFTER clipping is removed
            if (isChallenger && !isCompleted) {
              ctx.save();
              const pulseTime = Date.now() / 500;
              const nodeOffset = hashCode(node.id) % 1000;
              
              // Draw special frame based on selected style
              switch (challengerFrameStyle) {
                case 'spikes':
                  // Draw jagged spikes around the circle - shorter and smoother
                  const spikeCount = 24;
                  const baseAlpha = 0.85;
                  const animOffset = nodeOffset * 0.001; // Use node-specific offset for desync
                  
                  // Single path for all spikes for better performance
                  ctx.save();
                  ctx.fillStyle = `rgba(255, 50, 50, ${baseAlpha})`;
                  ctx.strokeStyle = `rgba(200, 30, 30, ${0.9})`;
                  ctx.lineWidth = 1.5;
                  
                  ctx.beginPath();
                  for (let i = 0; i < spikeCount; i++) {
                    const angle = (i / spikeCount) * Math.PI * 2;
                    const innerRadius = halfSize;
                    // Much shorter spikes - only 2-3 pixels out with gentle animation
                    const outerRadius = halfSize + 2.5 + Math.sin(pulseTime + i * 0.3 + animOffset) * 0.5;
                    
                    // Create triangular spikes with smaller angle
                    const angleWidth = 0.03; // Narrower spikes
                    const x1 = pos.x + Math.cos(angle - angleWidth) * innerRadius;
                    const y1 = pos.y + Math.sin(angle - angleWidth) * innerRadius;
                    const x2 = pos.x + Math.cos(angle) * outerRadius;
                    const y2 = pos.y + Math.sin(angle) * outerRadius;
                    const x3 = pos.x + Math.cos(angle + angleWidth) * innerRadius;
                    const y3 = pos.y + Math.sin(angle + angleWidth) * innerRadius;
                    
                    if (i === 0) {
                      ctx.moveTo(x1, y1);
                    } else {
                      ctx.lineTo(x1, y1);
                    }
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                  }
                  ctx.closePath();
                  ctx.fill();
                  ctx.stroke();
                  ctx.restore();
                  break;
                  
                case 'lightning':
                  // Draw electric arcs around the circle
                  ctx.strokeStyle = `rgba(100, 200, 255, ${0.6 + Math.sin(pulseTime) * 0.4})`;
                  ctx.lineWidth = 1.5;
                  const arcCount = 8;
                  for (let i = 0; i < arcCount; i++) {
                    const startAngle = (i / arcCount) * Math.PI * 2 + pulseTime * 0.002;
                    const endAngle = startAngle + Math.PI / 6;
                    const radius = halfSize + 5;
                    ctx.beginPath();
                    const steps = 5;
                    for (let j = 0; j <= steps; j++) {
                      const t = j / steps;
                      const angle = startAngle + (endAngle - startAngle) * t;
                      const jitter = Math.random() * 4 - 2;
                      const r = radius + jitter;
                      const x = pos.x + Math.cos(angle) * r;
                      const y = pos.y + Math.sin(angle) * r;
                      if (j === 0) ctx.moveTo(x, y);
                      else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                  }
                  break;
                  
                case 'sawblade':
                  // Draw rotating sawblade teeth
                  ctx.fillStyle = `rgba(200, 200, 200, ${0.5 + Math.sin(pulseTime) * 0.2})`;
                  const teeth = 24;
                  const rotation = pulseTime * 0.002;
                  ctx.beginPath();
                  for (let i = 0; i < teeth; i++) {
                    const angle = (i / teeth) * Math.PI * 2 + rotation;
                    const nextAngle = ((i + 1) / teeth) * Math.PI * 2 + rotation;
                    const innerRadius = halfSize;
                    const outerRadius = halfSize + (i % 2 === 0 ? 8 : 4);
                    const x1 = pos.x + Math.cos(angle) * innerRadius;
                    const y1 = pos.y + Math.sin(angle) * innerRadius;
                    const x2 = pos.x + Math.cos(angle) * outerRadius;
                    const y2 = pos.y + Math.sin(angle) * outerRadius;
                    const x3 = pos.x + Math.cos(nextAngle) * outerRadius;
                    const y3 = pos.y + Math.sin(nextAngle) * outerRadius;
                    const x4 = pos.x + Math.cos(nextAngle) * innerRadius;
                    const y4 = pos.y + Math.sin(nextAngle) * innerRadius;
                    if (i === 0) ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.lineTo(x4, y4);
                  }
                  ctx.closePath();
                  ctx.fill();
                  break;
                  
                case 'flames':
                  // Draw animated flames around the circle
                  const flameCount = 12;
                  for (let i = 0; i < flameCount; i++) {
                    const angle = (i / flameCount) * Math.PI * 2;
                    const flameHeight = 12 + Math.sin(pulseTime + i * 0.5) * 4;
                    const baseX = pos.x + Math.cos(angle) * halfSize;
                    const baseY = pos.y + Math.sin(angle) * halfSize;
                    const tipX = pos.x + Math.cos(angle) * (halfSize + flameHeight);
                    const tipY = pos.y + Math.sin(angle) * (halfSize + flameHeight);
                    
                    // Gradient for flame
                    const gradient = ctx.createLinearGradient(baseX, baseY, tipX, tipY);
                    gradient.addColorStop(0, `rgba(255, 100, 0, ${0.8})`);  
                    gradient.addColorStop(0.5, `rgba(255, 200, 0, ${0.6})`);
                    gradient.addColorStop(1, `rgba(255, 255, 100, ${0.2})`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(baseX, baseY);
                    const controlX1 = baseX + Math.cos(angle - 0.2) * flameHeight * 0.3;
                    const controlY1 = baseY + Math.sin(angle - 0.2) * flameHeight * 0.3;
                    const controlX2 = baseX + Math.cos(angle + 0.2) * flameHeight * 0.3;
                    const controlY2 = baseY + Math.sin(angle + 0.2) * flameHeight * 0.3;
                    ctx.quadraticCurveTo(controlX1, controlY1, tipX, tipY);
                    ctx.quadraticCurveTo(controlX2, controlY2, baseX, baseY);
                    ctx.fill();
                  }
                  break;
                  
                case 'crystals':
                  // Draw crystalline shards around the circle
                  ctx.fillStyle = `rgba(150, 50, 255, ${0.4 + Math.sin(pulseTime) * 0.2})`;
                  ctx.strokeStyle = `rgba(200, 100, 255, ${0.7})`;
                  ctx.lineWidth = 1;
                  const crystalCount = 8;
                  for (let i = 0; i < crystalCount; i++) {
                    const angle = (i / crystalCount) * Math.PI * 2 + Math.sin(pulseTime * 0.001 + i) * 0.1;
                    const innerRadius = halfSize;
                    const outerRadius = halfSize + 10 + Math.sin(pulseTime * 0.002 + i * 2) * 2;
                    const width = 4;
                    
                    const baseX = pos.x + Math.cos(angle) * innerRadius;
                    const baseY = pos.y + Math.sin(angle) * innerRadius;
                    const tipX = pos.x + Math.cos(angle) * outerRadius;
                    const tipY = pos.y + Math.sin(angle) * outerRadius;
                    const leftX = baseX + Math.cos(angle + Math.PI/2) * width;
                    const leftY = baseY + Math.sin(angle + Math.PI/2) * width;
                    const rightX = baseX + Math.cos(angle - Math.PI/2) * width;
                    const rightY = baseY + Math.sin(angle - Math.PI/2) * width;
                    
                    ctx.beginPath();
                    ctx.moveTo(leftX, leftY);
                    ctx.lineTo(tipX, tipY);
                    ctx.lineTo(rightX, rightY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                  }
                  break;
              }
              
              ctx.restore();
            }
          }
        } else if ((node.storyNodeType === 'boss' || node.storyNodeType === 'final_boss') && nodeImages.has(node.id)) {
          // Draw mechanism image for boss nodes with special framing
          const img = nodeImages.get(node.id)!;
          if (img.complete) {
            ctx.save();
            
            if (node.storyNodeType === 'boss') {
              // Boss: Draw image in center with tech frame
              const imageSize = halfSize * 1.2;
              
              // Create hexagonal clip for boss image
              ctx.beginPath();
              ctx.rect(pos.x - imageSize/2, pos.y - imageSize/2, imageSize, imageSize);
              ctx.clip();
              
              // Draw image
              ctx.globalAlpha = isCompleted ? 1 : isAvailable ? 0.9 : 0.4;
              ctx.drawImage(img, pos.x - imageSize/2, pos.y - imageSize/2, imageSize, imageSize);
              
              // Overlay effects
              if (!isCompleted && !isAvailable) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(pos.x - imageSize/2, pos.y - imageSize/2, imageSize, imageSize);
              } else if (isCompleted) {
                ctx.fillStyle = 'rgba(16, 185, 129, 0.2)';
                ctx.fillRect(pos.x - imageSize/2, pos.y - imageSize/2, imageSize, imageSize);
              } else if (isAvailable) {
                // Red tint for available boss
                ctx.fillStyle = 'rgba(239, 68, 68, 0.15)';
                ctx.fillRect(pos.x - imageSize/2, pos.y - imageSize/2, imageSize, imageSize);
              }
              
            } else if (node.storyNodeType === 'final_boss') {
              // Final Boss: Draw image with hexagonal mask
              const imageSize = halfSize * 0.7;
              
              // Create hexagonal clip
              ctx.beginPath();
              for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                const x = pos.x + Math.cos(angle) * imageSize;
                const y = pos.y + Math.sin(angle) * imageSize;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.closePath();
              ctx.clip();
              
              // Draw image
              ctx.globalAlpha = isCompleted ? 1 : isAvailable ? 0.95 : 0.3;
              ctx.drawImage(img, pos.x - imageSize, pos.y - imageSize, imageSize * 2, imageSize * 2);
              
              // Overlay effects
              if (!isCompleted && !isAvailable) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(pos.x - imageSize, pos.y - imageSize, imageSize * 2, imageSize * 2);
              } else if (isCompleted) {
                ctx.fillStyle = 'rgba(16, 185, 129, 0.25)';
                ctx.fillRect(pos.x - imageSize, pos.y - imageSize, imageSize * 2, imageSize * 2);
              } else if (isAvailable) {
                // Gold tint for available final boss
                ctx.fillStyle = 'rgba(250, 182, 23, 0.2)';
                ctx.fillRect(pos.x - imageSize, pos.y - imageSize, imageSize * 2, imageSize * 2);
              }
            }
            
            ctx.restore();
          }
        }
        
        // Draw border only for non-boss special nodes
        if ((node.storyNodeType !== 'normal' && node.storyNodeType !== 'boss' && node.storyNodeType !== 'final_boss') || node.id === 'start') {
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = strokeWidth;
          ctx.strokeRect(pos.x - halfSize, pos.y - halfSize, halfSize * 2, halfSize * 2);
        }
      }
      
      // Draw checkmark for all completed nodes (including mechanisms)
      if (isCompleted && node.id !== 'start') {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(pos.x - nodeSize/4, pos.y);
        ctx.lineTo(pos.x - nodeSize/8, pos.y + nodeSize/4);
        ctx.lineTo(pos.x + nodeSize/4, pos.y - nodeSize/4);
        ctx.stroke();
      }
      
      // Draw node label
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 10px Orbitron';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      if (node.id === 'start') {
        // START text INSIDE the hemisphere with better design
        ctx.save();
        
        // Create text with gradient effect
        ctx.font = 'bold 28px Tahoma';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Add strong black outline
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 4;
        ctx.strokeText('START', pos.x, pos.y - 20);
        
        // White text with glow
        ctx.shadowColor = 'rgba(250, 182, 23, 0.8)';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#ffffff';
        ctx.fillText('START', pos.x, pos.y - 20);
        
        ctx.restore();
        // Reset font for other nodes
        ctx.font = 'bold 10px Orbitron';
      } else if (node.storyNodeType === 'boss') {
        // Draw text INSIDE the boss square at the bottom
        ctx.save();
        
        // Draw at bottom inside the square with dark background card
        ctx.save();
        // Draw dark background rectangle for text
        const textWidth = 70;
        const textHeight = 20;
        const textY = pos.y + nodeSize - 20;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(pos.x - textWidth/2, textY - textHeight/2, textWidth, textHeight);

        // Draw text on top of background
        ctx.font = 'bold 13px Arial';
        ctx.fillStyle = isCompleted ? '#10b981' : isAvailable ? '#ef4444' : '#9ca3af';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('MINI BOSS', pos.x, textY);
        ctx.restore();
      } else if (node.storyNodeType === 'final_boss') {
        // Draw text INSIDE the final boss square at the bottom with dark background
        ctx.save();

        // Draw dark background rectangle for both text lines
        const textWidth = 140;
        const textHeight = 45;
        const textCenterY = pos.y + nodeSize - 25;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(pos.x - textWidth/2, textCenterY - textHeight/2, textWidth, textHeight);

        // Draw main title
        ctx.font = 'bold 16px Impact';
        ctx.fillStyle = isCompleted ? '#10b981' : isAvailable ? '#fab617' : '#9ca3af'; // Yellow text for available mini-boss
        ctx.textAlign = 'center';
        ctx.fillText('FINAL BOSS', pos.x, pos.y + nodeSize - 35);

        // Draw subtitle
        ctx.font = 'bold 12px Verdana';
        ctx.fillStyle = isCompleted ? '#ffffff' : isAvailable ? '#10b981' : '#6b7280';
        ctx.fillText('THE APEX MECHANISM', pos.x, pos.y + nodeSize - 15);
        ctx.restore();
      } else if (node.storyNodeType === 'event') {
        // Draw EVENT text inside the node with curved text along bottom inner edge
        ctx.save();
        const eventTitles = [
          'The Lost Shadows', 'Frozen Echo', 'Binary Storm', 'Void Walker',
          'Crystal Nexus', 'Shadow Protocol', 'Iron Forge', 'Plasma Core',
          'Quantum Leap', 'Neural Link', 'Time Rift', 'Data Stream',
          'The Talisman', 'Neon Dreams', 'Ghost Signal', 'Circuit Break'
        ];
        
        // Get a deterministic title based on node ID
        let titleHash = 0;
        for (let i = 0; i < node.id.length; i++) {
          titleHash = ((titleHash << 5) - titleHash) + node.id.charCodeAt(i);
        }
        const eventTitle = eventTitles[Math.abs(titleHash) % eventTitles.length];
        
        // Draw curved text INSIDE the circle along the bottom with background
        ctx.font = '500 11px Verdana'; // Lighter weight for better readability
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Calculate text arc parameters
        const textRadius = nodeSize - 12; // Inside the circle, with padding from edge
        const arcText = eventTitle.toUpperCase();
        const letterSpacing = 0.16; // More spacing between letters for better readability
        const totalArc = letterSpacing * (arcText.length - 1);
        const startAngle = Math.PI / 2 + totalArc / 2; // Start from bottom, centered
        
        // Draw background arc for event title
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.lineWidth = 14;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, textRadius, startAngle - totalArc - 0.1, startAngle + 0.1);
        ctx.stroke();
        ctx.restore();
        
        // Draw each letter curved along the bottom inside of the circle
        ctx.fillStyle = isCompleted ? '#ffffff' : isAvailable ? '#ffffff' : '#9ca3af'; // Keep title white when available
        for (let i = 0; i < arcText.length; i++) {
          const angle = startAngle - (i * letterSpacing);
          const charX = pos.x + Math.cos(angle) * textRadius;
          const charY = pos.y + Math.sin(angle) * textRadius;
          
          ctx.save();
          ctx.translate(charX, charY);
          ctx.rotate(angle - Math.PI / 2); // Rotate to follow the curve
          ctx.fillText(arcText[i], 0, 0);
          ctx.restore();
        }
        
        // Draw "EVENT" curved at the top of the circle with background
        ctx.font = 'bold 11px Trebuchet MS';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Add semi-transparent background for EVENT text
        const eventText = 'EVENT';
        const topRadius = nodeSize - 10; // EVENT text positioned away from rim
        const topLetterSpacing = 0.15;
        const topTotalArc = topLetterSpacing * (eventText.length - 1);
        const topStartAngle = -Math.PI / 2 - topTotalArc / 2;
        
        // Draw background arc for EVENT text
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.lineWidth = 14;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, topRadius, topStartAngle - 0.1, topStartAngle + topTotalArc + 0.1);
        ctx.stroke();
        ctx.restore();
        
        // Draw EVENT text
        ctx.fillStyle = '#8b5cf6';
        for (let i = 0; i < eventText.length; i++) {
          const angle = topStartAngle + (i * topLetterSpacing);
          const charX = pos.x + Math.cos(angle) * topRadius;
          const charY = pos.y + Math.sin(angle) * topRadius;
          
          ctx.save();
          ctx.translate(charX, charY);
          ctx.rotate(angle + Math.PI / 2);
          ctx.fillText(eventText[i], 0, 0);
          ctx.restore();
        }
        ctx.restore();
      } else {
        // Normal nodes - show number if available
        const nodeNumber = node.label.match(/\d+/) || [''];
        ctx.fillText(nodeNumber[0], pos.x, pos.y);
      }
    });
    
    console.log("Canvas render complete");
  }, [treeData, canvasSize, viewportOffset, completedNodes, nodeImages, eventImages, imagesLoaded, panOffset, zoom, hoveredNode, animationTick, challengerEffect, challengerFrameStyle]);

  // Separate effect for jump button visibility to avoid infinite loop
  useEffect(() => {
    if (treeData) {
      const startNode = treeData.nodes.find(n => n.id === 'start');
      if (startNode) {
        // Simple check: if we've scrolled up more than 100 pixels, show the button
        // Show button when scrolled up from the start position
        const isScrolledUp = viewportOffset > -200 || panOffset.y > 50;
        setShowJumpButton(isScrolledUp);
      }
    }
  }, [treeData, viewportOffset, panOffset.y]);

  // Animation loop for continuous hover effects and challenger glitch
  useEffect(() => {
    // Skip animation in preview mode to prevent performance issues
    if (previewMode) return;

    // Clear any existing animation
    if (animationIdRef.current) {
      cancelAnimationFrame(animationIdRef.current);
      animationIdRef.current = null;
    }

    // Check if there are any challenger nodes that need animation
    const hasChallenger = treeData?.nodes?.some(node =>
      node.challenger === true && node.storyNodeType === 'normal'
    ) || false;

    let lastTime = 0;
    const targetFPS = 30;
    const frameDelay = 1000 / targetFPS;

    const animate = (currentTime: number) => {
      // Throttle to target FPS
      if (currentTime - lastTime < frameDelay) {
        animationIdRef.current = requestAnimationFrame(animate);
        return;
      }
      lastTime = currentTime;

      // Animate for hover effects OR if there are challenger nodes
      if (hoveredNode || hasChallenger) {
        // Force a redraw by updating animation tick
        setAnimationTick(prev => prev + 1);
        animationIdRef.current = requestAnimationFrame(animate);
      } else {
        animationIdRef.current = null;
      }
    };

    // Start animation if needed
    if ((hoveredNode && (hoverEffectStyle === 4 || hoverEffectStyle === 1 || hoverEffectStyle === 3)) || hasChallenger) {
      animationIdRef.current = requestAnimationFrame(animate);
    }

    return () => {
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
        animationIdRef.current = null;
      }
    };
  }, [hoveredNode, treeData, hoverEffectStyle, previewMode]);

  // Handle mouse events for panning
  const handleMouseDown = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    setIsMouseDown(true);
    setMouseDownPos({ x: e.clientX, y: e.clientY });
    setPanStart({ x: e.clientX, y: e.clientY });
    setHasDragged(false);
  }, []);
  
  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    // Store mouse position for tooltip - only update if changed significantly
    const rect = canvasRef.current?.getBoundingClientRect();
    if (rect) {
      const newX = e.clientX - rect.left;
      const newY = e.clientY - rect.top;
      // Only update if mouse moved more than 5 pixels to prevent re-render loops
      setMousePosition(prev => {
        if (Math.abs(prev.x - newX) > 5 || Math.abs(prev.y - newY) > 5) {
          return { x: newX, y: newY };
        }
        return prev;
      });
    }

    // Handle hover detection when not dragging
    if (!isMouseDown && canvasRef.current && treeData) {
      const canvas = canvasRef.current;
      const rect = canvas.getBoundingClientRect();
      // Scale mouse coordinates to match canvas internal resolution
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;

      // Apply same position adjustments as in draw function
      const nodes = treeData.nodes.map(node => {
        const adjustedNode = { ...node };

        if (node.storyNodeType === 'event') {
          adjustedNode.x = node.x + 25; // Reduced for upper-left positioning
          adjustedNode.y = node.y + 20; // 5px more upward than other nodes
        } else if (node.storyNodeType === 'boss') {
          adjustedNode.x = node.x + 40; // Shifted 5px to the right
          adjustedNode.y = node.y + 35;
        } else if (node.storyNodeType === 'final_boss') {
          adjustedNode.x = node.x + 75; // Center like START node
          adjustedNode.y = node.y + 20; // Move 40px higher up
        }

        return adjustedNode;
      });

      // Calculate bounds INCLUDING node sizes (same as draw function)
      let actualMinX = Infinity, actualMaxX = -Infinity;
      let actualMinY = Infinity, actualMaxY = -Infinity;

      nodes.forEach(node => {
        let nodeSize = 31.5; // normal nodes (5% larger) - must match render exactly
        if (node.id === 'start') nodeSize = 75; // MUST match actual render size (line 571)
        else if (node.storyNodeType === 'event') nodeSize = 67; // 12% bigger
        else if (node.storyNodeType === 'boss') nodeSize = 90; // MUST match actual render size (line 581)
        else if (node.storyNodeType === 'final_boss') nodeSize = 130; // MUST match actual render size (line 586)

        actualMinX = Math.min(actualMinX, node.x - nodeSize);
        actualMaxX = Math.max(actualMaxX, node.x + nodeSize);
        actualMinY = Math.min(actualMinY, node.y - nodeSize);
        actualMaxY = Math.max(actualMaxY, node.y + nodeSize);
      });

      const minX = Math.min(...nodes.map(n => n.x));
      const maxX = Math.max(...nodes.map(n => n.x));
      const minY = Math.min(...nodes.map(n => n.y));
      const maxY = Math.max(...nodes.map(n => n.y));

      const treeWidth = maxX - minX;
      const treeHeight = maxY - minY;
      const actualTreeWidth = actualMaxX - actualMinX;

      const padding = 30;
      const treeScaleX = (canvas.width - padding * 2) / treeWidth;
      const scale = treeScaleX * 0.77; // Match the render function scale EXACTLY (was 0.85, should be 0.77)
      const scaledTreeHeight = treeHeight * scale;

      const startNodeInHover = nodes.find(n => n.id === 'start'); // Find start node first

      const transform = (nodeX: number, nodeY: number) => {
        const scaledX = (nodeX - minX) * scale;
        const scaledY = (nodeY - minY) * scale;

        // Use the same offset calculation as the draw function
        let offsetX;
        if (startNodeInHover) {
          const startScaledX = (startNodeInHover.x - minX) * scale;
          const centerAdjustment = -55; // Match the render function offset - MUST MATCH EXACTLY
          offsetX = (canvas.width / 2) - startScaledX + centerAdjustment;
        } else {
          const leftOverflow = (minX - actualMinX) * scale;
          const padding = 30;
          offsetX = padding + leftOverflow;
        }

        // Position the start node near the bottom of the canvas
        let offsetY;
        if (startNodeInHover) {
          const startScaledY = (startNodeInHover.y - minY) * scale;
          // Must match the draw function's offsetY calculation exactly
          offsetY = canvas.height - startScaledY + viewportOffset + 240;
        } else {
          offsetY = canvas.height - scaledTreeHeight + viewportOffset - padding;
        }

        return {
          x: scaledX + offsetX + panOffset.x,
          y: scaledY + offsetY + panOffset.y
        };
      };

      // Check if hover is on any available node
      let foundHoverNode = null;

      // Debug logging only when hovering (removed to prevent console spam)

      for (const node of nodes) {
        // Skip start node
        if (node.id === 'start') continue;

        // In preview mode, allow hovering over all nodes
        if (previewMode) {
          // Allow hover on all nodes in preview mode
        } else {
          // Only hover over available nodes (same logic as isNodeAvailable)
          const isNodeAvailableForHover = treeData.connections.some(conn => {
            let connectedNodeId = null;
            if (conn.from === node.id) {
              connectedNodeId = conn.to;
            } else if (conn.to === node.id) {
              connectedNodeId = conn.from;
            }

            if (!connectedNodeId || !completedNodes.has(connectedNodeId)) {
              return false;
            }

            // Find the connected completed node
            const connectedNode = nodes.find(n => n.id === connectedNodeId);
            if (!connectedNode) return false;

            // Only allow upward progression (lower Y values = further up the tree)
            return node.y < connectedNode.y;
          });

          // Process nodes that are either completed or available to play
          if (!completedNodes.has(node.id) && !isNodeAvailableForHover) {
            return; // Skip this node if not available in normal mode
          }
        }

        // Process hover detection for this node
        {
          let pos = transform(node.x, node.y);

          // Apply the EXACT same position adjustments as in the render function
          // Move all non-start nodes up by 45 pixels
          if (node.id !== 'start') {
            pos.y -= 45;
          }

          // Special positioning for event nodes - move 7px left and 3px up
          if (node.storyNodeType === 'event') {
            pos.x -= 7;
            pos.y -= 3;
          }

          let nodeSize = 31.5; // normal nodes (5% larger) - MUST match render function exactly
          if (node.id === 'start') nodeSize = 75;
          else if (node.storyNodeType === 'event') nodeSize = 67;
          else if (node.storyNodeType === 'boss') nodeSize = 90;
          else if (node.storyNodeType === 'final_boss') nodeSize = 130;

          let inBounds = false;
          if (node.storyNodeType === 'event' || node.storyNodeType === 'normal') {
            // Circle hit detection for events and normal mechanism nodes
            const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
            inBounds = distance <= nodeSize;
          } else {
            // Square hit detection for boss/final_boss/start - nodeSize is already the half-size
            inBounds = Math.abs(x - pos.x) <= nodeSize && Math.abs(y - pos.y) <= nodeSize;
          }

          if (inBounds) {
            console.log('Found node in bounds:', node.id,
              'Position:', pos,
              'Node size:', nodeSize,
              'Mouse:', { x, y },
              'Distance from center:', node.storyNodeType === 'event' || node.storyNodeType === 'normal'
                ? Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2))
                : `x: ${Math.abs(x - pos.x)}, y: ${Math.abs(y - pos.y)}`
            );
            foundHoverNode = node;
            break;
          }
        }
      }

      if (foundHoverNode !== hoveredNode) {
        console.log('Hover changed to:', foundHoverNode?.id || 'none', 'Available nodes checked:', nodes.filter(n => completedNodes.has(n.id) || n.id === 'start').map(n => n.id));
      }
      // Always set hoveredNode for animation purposes
      setHoveredNode(foundHoverNode);
    }

    if (!isMouseDown) return;

    // Check if mouse moved enough to start panning (5 pixel threshold)
    const distance = Math.sqrt(
      Math.pow(e.clientX - mouseDownPos.x, 2) +
      Math.pow(e.clientY - mouseDownPos.y, 2)
    );

    if (distance > 5) {
      setHasDragged(true);
      if (!isPanning) {
        setIsPanning(true);
      }
    }

    if (!isPanning) return;

    // Only allow vertical panning (no horizontal movement)
    const deltaY = e.clientY - panStart.y;
    
    setPanOffset(prev => {
      const newY = prev.y + deltaY;
      
      // Find the final boss node to set scroll limit
      const finalBossNode = treeData?.nodes.find(n => n.storyNodeType === 'final_boss');
      if (finalBossNode && canvasRef.current) {
        const canvas = canvasRef.current;
        const nodes = treeData.nodes;
        const minY = Math.min(...nodes.map(n => n.y));
        const maxY = Math.max(...nodes.map(n => n.y));
        
        // Simply allow scrolling the full height of the tree plus extra room
        // This ensures we can always see the final boss at the top
        const treeHeight = maxY - minY;
        const scale = 0.77; // Current scale factor
        const scaledTreeHeight = treeHeight * scale;
        
        // Allow scrolling up by the full scaled tree height plus some extra
        // This guarantees the final boss can reach the top of the viewport
        const maxScroll = scaledTreeHeight + 10000; // Increased scroll limit to ensure final boss is reachable
        
        const limitedY = Math.min(newY, maxScroll);
        
        // Allow scrolling closer to the actual bottom
        // This ensures consistent behavior between wheel scrolling and panning
        return {
          x: 0, // Always keep X at 0 - no horizontal panning
          y: limitedY // Allow free panning in both directions
        };
      }
      
      return {
        x: 0,
        y: newY
      };
    });
    setPanStart({ x: e.clientX, y: e.clientY });
  }, [isMouseDown, isPanning, mouseDownPos, panStart, treeData, completedNodes, viewportOffset, panOffset, hoveredNode]);
  
  const handleMouseUp = useCallback(() => {
    setIsMouseDown(false);
    setIsPanning(false);
    // Don't clear hasDragged here - let click handler check it first
    // It will be cleared on next mousedown
  }, []);
  
  const handleMouseWheel = useCallback((e: React.WheelEvent<HTMLCanvasElement>) => {
    e.preventDefault();
    
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const rect = canvas.getBoundingClientRect();
    // Scale mouse coordinates to match canvas internal resolution
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;
    
    // Calculate world position before zoom
    const worldX = (mouseX - panOffset.x) / zoom;
    const worldY = (mouseY - panOffset.y) / zoom;
    
    // Apply zoom
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.max(0.3, Math.min(3, zoom * delta));
    
    // Calculate new pan to keep mouse position fixed
    const newPanX = mouseX - worldX * newZoom;
    const newPanY = mouseY - worldY * newZoom;
    
    setZoom(newZoom);
    setPanOffset({ 
      x: newPanX, 
      y: newPanY
    });
  }, [zoom, panOffset]);
  
  // Helper function to check if a node is available to play
  const isNodeAvailable = useCallback((node: StoryNode | null) => {
    if (!node || !treeData) return false;
    if (node.id === 'start') return false;
    if (completedNodes.has(node.id)) return true; // Already completed nodes can be replayed
    
    // Check if this node is adjacent to a completed node and allows upward progression
    return treeData.connections.some(conn => {
      let connectedNodeId = null;
      if (conn.from === node.id) {
        connectedNodeId = conn.to;
      } else if (conn.to === node.id) {
        connectedNodeId = conn.from;
      }
      
      if (!connectedNodeId || !completedNodes.has(connectedNodeId)) {
        return false;
      }
      
      // Find the connected completed node
      const connectedNode = treeData.nodes.find(n => n.id === connectedNodeId);
      if (!connectedNode) return false;
      
      // Only allow upward progression (lower Y values = further up the tree)
      return node.y < connectedNode.y;
    });
  }, [treeData, completedNodes]);
  
  // Handle canvas click for node selection
  const handleCanvasClick = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {
    console.log("Click handler called, hasDragged:", hasDragged);
    
    // Don't process clicks if we dragged
    if (hasDragged) {
      console.log("Click ignored due to dragging");
      return;
    }
    
    if (!canvasRef.current || !treeData) return;
    
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    // Scale mouse coordinates to match canvas internal resolution
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (event.clientX - rect.left) * scaleX;
    const y = (event.clientY - rect.top) * scaleY;
    
    // Apply same position adjustments as in draw function
    const nodes = treeData.nodes.map(node => {
      const adjustedNode = { ...node };
      
      if (node.storyNodeType === 'event') {
        adjustedNode.x = node.x + 25; // Reduced for upper-left positioning
        adjustedNode.y = node.y + 20; // 5px more upward than other nodes
      } else if (node.storyNodeType === 'boss') {
        adjustedNode.x = node.x + 40; // Shifted 5px to the right  
        adjustedNode.y = node.y + 35;
      } else if (node.storyNodeType === 'final_boss') {
        adjustedNode.x = node.x + 75; // Center like START node
        adjustedNode.y = node.y + 20; // Move 40px higher up
      }
      
      return adjustedNode;
    });
    
    // Calculate bounds INCLUDING node sizes (same as draw function)
    let actualMinX = Infinity, actualMaxX = -Infinity;
    let actualMinY = Infinity, actualMaxY = -Infinity;

    nodes.forEach(node => {
      let nodeSize = 31.5; // normal nodes (5% larger) - must match render exactly
      if (node.id === 'start') nodeSize = 75; // MUST match actual render size (line 571)
      else if (node.storyNodeType === 'event') nodeSize = 67; // 12% bigger
      else if (node.storyNodeType === 'boss') nodeSize = 90; // MUST match actual render size (line 581)
      else if (node.storyNodeType === 'final_boss') nodeSize = 130; // MUST match actual render size (line 586)
      
      actualMinX = Math.min(actualMinX, node.x - nodeSize);
      actualMaxX = Math.max(actualMaxX, node.x + nodeSize);
      actualMinY = Math.min(actualMinY, node.y - nodeSize);
      actualMaxY = Math.max(actualMaxY, node.y + nodeSize);
    });
    
    const minX = Math.min(...nodes.map(n => n.x));
    const maxX = Math.max(...nodes.map(n => n.x));
    const minY = Math.min(...nodes.map(n => n.y));
    const maxY = Math.max(...nodes.map(n => n.y));
    
    const treeWidth = maxX - minX;
    const treeHeight = maxY - minY;
    const actualTreeWidth = actualMaxX - actualMinX;
    
    const padding = 30;
    const treeScaleX = (canvas.width - padding * 2) / treeWidth;
    const scale = treeScaleX * 0.77; // Match the render function scale EXACTLY (was 0.85, should be 0.77)
    const scaledTreeHeight = treeHeight * scale;
    
    const startNodeInClick = nodes.find(n => n.id === 'start'); // Find start node first
    
    const transform = (nodeX: number, nodeY: number) => {
      const scaledX = (nodeX - minX) * scale;
      const scaledY = (nodeY - minY) * scale;
      
      // Use the same offset calculation as the draw function
      let offsetX;
      if (startNodeInClick) {
        const startScaledX = (startNodeInClick.x - minX) * scale;
        const centerAdjustment = -55; // Match the render function offset - MUST MATCH EXACTLY
        offsetX = (canvas.width / 2) - startScaledX + centerAdjustment;
      } else {
        const leftOverflow = (minX - actualMinX) * scale;
        const padding = 30;
        offsetX = padding + leftOverflow;
      }
      
      // Position the start node near the bottom of the canvas
      let offsetY;
      if (startNodeInClick) {
        const startScaledY = (startNodeInClick.y - minY) * scale;
        // Must match the draw function's offsetY calculation exactly
        offsetY = canvas.height - startScaledY + viewportOffset + 240;
      } else {
        offsetY = canvas.height - scaledTreeHeight + viewportOffset - padding;
      }
      
      return {
        x: scaledX + offsetX + panOffset.x,
        y: scaledY + offsetY + panOffset.y
      };
    };
    
    // Check if click is on any node
    for (const node of nodes) {
      let pos = transform(node.x, node.y);

      // Apply the EXACT same position adjustments as in the render function
      // Move all non-start nodes up by 45 pixels
      if (node.id !== 'start') {
        pos.y -= 45;
      }

      // Special positioning for event nodes - move 7px left and 3px up
      if (node.storyNodeType === 'event') {
        pos.x -= 7;
        pos.y -= 3;
      }

      let nodeSize = 31.5; // normal nodes (5% larger) - MUST match render function exactly
      if (node.id === 'start') nodeSize = 75;
      else if (node.storyNodeType === 'event') nodeSize = 67;
      else if (node.storyNodeType === 'boss') nodeSize = 90;
      else if (node.storyNodeType === 'final_boss') nodeSize = 130;
      
      let inBounds = false;
      if (node.storyNodeType === 'event' || node.storyNodeType === 'normal') {
        // Circle hit detection for events and normal mechanism nodes
        const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
        inBounds = distance <= nodeSize;
      } else {
        // Square hit detection for boss/final_boss/start - nodeSize is already the half-size
        inBounds = Math.abs(x - pos.x) <= nodeSize && Math.abs(y - pos.y) <= nodeSize;
      }
      
      if (inBounds) {
        // Don't allow selecting or clicking the start node
        if (node.id === 'start') {
          break;
        }
        
        // In preview mode, allow clicking any node
        if (previewMode) {
          setHoveredNode(null);
          setSelectedNode(node);
          console.log('Preview mode - selected node:', node);
          break;
        }

        // Debug: Check what connections exist for this node
        const nodeConnections = treeData.connections.filter(conn =>
          conn.from === node.id || conn.to === node.id
        );
        console.log(`Connections for ${node.id}:`, nodeConnections.length, nodeConnections);

        // Check if this node is adjacent to a completed node and allows upward progression
        const isAdjacent = treeData.connections.some(conn => {
          let connectedNodeId = null;
          if (conn.from === node.id) {
            connectedNodeId = conn.to;
          } else if (conn.to === node.id) {
            connectedNodeId = conn.from;
          }
          
          console.log(`Checking connection: from=${conn.from}, to=${conn.to}, connectedNodeId=${connectedNodeId}`);
          
          if (!connectedNodeId) {
            console.log('No connected node ID found');
            return false;
          }
          
          if (!completedNodes.has(connectedNodeId)) {
            console.log(`Connected node ${connectedNodeId} is not completed`);
            return false;
          }
          
          // Find the connected completed node
          const connectedNode = nodes.find(n => n.id === connectedNodeId);
          if (!connectedNode) {
            console.log(`Connected node ${connectedNodeId} not found in nodes array`);
            return false;
          }
          
          console.log(`Adjacency check for ${node.id}: connected to ${connectedNodeId}, node.y=${node.y}, connectedNode.y=${connectedNode.y}`);
          
          // Only allow upward progression (lower Y values = further up the tree)
          // Players can unlock nodes that are higher up (have lower Y values)
          return node.y < connectedNode.y;
        });
        
        // Only allow clicking if node is adjacent to a completed node
        if (!completedNodes.has(node.id) && isAdjacent) {
          setHoveredNode(null); // Clear hover state when selecting a node
          setSelectedNode(node);
          // Don't auto-complete the node anymore - let user click Complete button
          // Auto-scroll removed - camera stays where user positioned it
        } else if (completedNodes.has(node.id)) {
          // Allow uncompleting nodes (for testing)
          const newCompleted = new Set(completedNodes);
          newCompleted.delete(node.id);
          setCompletedNodes(newCompleted);
        }
        break;
      }
    }
  }, [treeData, viewportOffset, completedNodes, canvasSize, hasDragged, panOffset, zoom]);

  // Handle mouse wheel scrolling with proper isolation
  const handleWheel = useCallback((event: React.WheelEvent<HTMLDivElement>) => {
    if (!treeData || !canvasRef.current) return;
    
    // Prevent page scroll when over canvas
    event.preventDefault();
    event.stopPropagation();
    
    // Calculate max scroll based on tree size
    const nodes = treeData.nodes;
    
    // Calculate bounds INCLUDING node sizes
    let actualMinX = Infinity, actualMaxX = -Infinity;
    let actualMinY = Infinity, actualMaxY = -Infinity;
    
    nodes.forEach(node => {
      let nodeSize = 31.5; // normal nodes (5% larger) - must match render exactly
      if (node.id === 'start') nodeSize = 75; // MUST match actual render size (line 571)
      else if (node.storyNodeType === 'event') nodeSize = 67; // 12% bigger
      else if (node.storyNodeType === 'boss') nodeSize = 90; // MUST match actual render size (line 581)
      else if (node.storyNodeType === 'final_boss') nodeSize = 130; // MUST match actual render size (line 586)
      
      actualMinX = Math.min(actualMinX, node.x - nodeSize);
      actualMaxX = Math.max(actualMaxX, node.x + nodeSize);
      actualMinY = Math.min(actualMinY, node.y - nodeSize);
      actualMaxY = Math.max(actualMaxY, node.y + nodeSize);
    });
    
    const minX = Math.min(...nodes.map(n => n.x));
    const maxX = Math.max(...nodes.map(n => n.x));
    const minY = Math.min(...nodes.map(n => n.y));
    const maxY = Math.max(...nodes.map(n => n.y));
    const treeWidth = maxX - minX;
    const treeHeight = maxY - minY;
    const actualTreeWidth = actualMaxX - actualMinX;
    
    const padding = 30;
    const scaleX = (canvasSize.width - padding * 2) / treeWidth;
    const scale = scaleX * 0.77; // Match the drawing scale!
    const scaledTreeHeight = treeHeight * scale;
    
    // Allow scrolling the full tree height plus extra room for final boss
    const maxPossibleOffset = scaledTreeHeight + 10000; // Increased to match pan handler limit - ensures final boss is accessible
    
    // Minimum offset to allow scrolling closer to the actual bottom
    // Less restrictive to reduce the gap below the start node
    const minOffset = -500; // Allow more room to scroll below start node
    
    // Scroll with mouse wheel (inverted so scrolling down moves tree up)
    const scrollSpeed = 50;
    const newOffset = Math.max(minOffset, Math.min(maxPossibleOffset, viewportOffset - event.deltaY * scrollSpeed / 100));
    setViewportOffset(newOffset);
  }, [treeData, viewportOffset, canvasSize]);

  // Show loading only briefly on initial mount
  if (!mounted && !previewMode) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-yellow-500 text-xl">Loading Story Mode...</div>
      </div>
    );
  }

  // Check if no tree data is available
  if (!treeData || !treeData.nodes || treeData.nodes.length === 0) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="text-yellow-500 text-xl mb-4">No Story Tree Data Found</div>
          <div className="text-gray-400">
            <p>Looking for "V1" or "test 5" story trees...</p>
            <p className="mt-2">Available trees: {storyTrees?.map(t => t.name).join(", ") || "None"}</p>
            <p className="mt-4 text-sm">Please create a story tree in the admin panel first.</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen">
      {/* Header */}
      <div className="bg-black/80 backdrop-blur-sm border-b-2 border-yellow-500/50 p-4 mb-6">
        <div className="flex items-center justify-between max-w-[1600px] mx-auto px-5">
          <h1 className="text-2xl font-bold text-yellow-500 font-orbitron tracking-wider">
            STORY MODE - CHAPTER 1
          </h1>

        </div>
      </div>

      {/* Main Content - Wider container for better layout */}
      <div className="max-w-[1600px] mx-auto pl-5">
        {/* Two Column Layout - adjusted to reduce gap */}
        <div className="flex gap-4">
          {/* Left Column - Tree Canvas - fixed width */}
          <div ref={containerRef} className="flex-shrink-0 overflow-hidden" style={{ width: '503px' }}>
            {/* Canvas Container with Style Q background */}
            <div 
              className="relative rounded-lg" 
              style={{ 
                width: `${canvasSize.width}px`,
                height: `${canvasSize.height}px`,
                background: 'rgba(255, 255, 255, 0.005)',
                backdropFilter: 'blur(1px)',
                border: '1px solid rgba(255, 255, 255, 0.015)',
                boxShadow: '0 0 25px rgba(0, 0, 0, 0.3) inset',
                touchAction: 'none'  // Prevent touch scrolling
              }}
              onWheel={handleWheel}
              onWheelCapture={(e) => {
                e.preventDefault();
                e.stopPropagation();
              }}
            >
              {/* Canvas */}
              <canvas
                ref={canvasRef}
                width={canvasSize.width}
                height={canvasSize.height}
                className={`${isPanning ? 'cursor-grabbing' : 'cursor-pointer'}`}
                style={{ display: 'block' }}
                onClick={handleCanvasClick}
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                onWheel={handleMouseWheel}
                style={{ imageRendering: 'crisp-edges' }}
              />
              
              {/* Fade gradient with blur at top */}
              <div className="absolute inset-x-0 top-0 h-60 pointer-events-none z-10">
                {/* Progressive blur layers - reduced by 25% and moved higher */}
                <div className="absolute inset-x-0 top-0 h-12 backdrop-blur-md" />
                <div className="absolute inset-x-0 top-0 h-20 backdrop-blur-sm" />
                <div className="absolute inset-x-0 top-0 h-28 backdrop-blur-[3px]" />
                <div className="absolute inset-x-0 top-0 h-36 backdrop-blur-[2px]" />
                <div className="absolute inset-x-0 top-0 h-44 backdrop-blur-[1px]" />
                {/* Gradient overlay - back to original size */}
                <div className="absolute inset-x-0 top-0 h-60 bg-gradient-to-b from-black/85 via-black/75 to-transparent" />
              </div>
              
              {/* Effect Selectors */}
              <div className="absolute top-4 right-4 z-30 flex gap-2">
                {/* Challenger Frame Selector */}
                <select
                  value={challengerFrameStyle}
                  onChange={(e) => setChallengerFrameStyle(e.target.value as 'spikes' | 'lightning' | 'sawblade' | 'flames' | 'crystals')}
                  className="px-3 py-1 bg-black/60 border border-red-500/40 rounded-md text-red-500 text-xs font-orbitron uppercase tracking-wider cursor-pointer hover:bg-red-500/20 hover:border-red-500/60 transition-all duration-200"
                >
                  <option value="spikes">Frame: Spikes</option>
                  <option value="lightning">Frame: Lightning</option>
                  <option value="sawblade">Frame: Sawblade</option>
                  <option value="flames">Frame: Flames</option>
                  <option value="crystals">Frame: Crystals</option>
                </select>
                
                {/* Challenger Effect Selector */}
                <select
                  value={challengerEffect}
                  onChange={(e) => setChallengerEffect(e.target.value as 'quantum1' | 'quantum2' | 'quantum3')}
                  className="px-3 py-1 bg-black/60 border border-cyan-500/40 rounded-md text-cyan-500 text-xs font-orbitron uppercase tracking-wider cursor-pointer hover:bg-cyan-500/20 hover:border-cyan-500/60 transition-all duration-200"
                >
                  <option value="quantum1">Quantum: Ripple Wave</option>
                  <option value="quantum2">Quantum: Phase Shift</option>
                  <option value="quantum3">Quantum: Dimensional Tear</option>
                </select>
              </div>
              
              {/* Hover Tooltip - Show in both preview and normal mode when admin data is loaded */}
              {(previewMode || attempt2Config) && hoveredNode && (
                <div
                  className="absolute z-40 bg-gray-900/95 border-2 border-yellow-500/50 rounded-lg p-3 pointer-events-none"
                  style={{
                    left: `${Math.min(mousePosition.x + 10, canvasSize.width - 250)}px`,
                    top: `${Math.min(mousePosition.y + 10, canvasSize.height - 150)}px`,
                    minWidth: '200px'
                  }}
                >
                  <div className="text-sm">
                    <div className="font-bold text-yellow-400 mb-2">
                      {hoveredNode.label || hoveredNode.id}
                      <span className="text-gray-400 ml-1 text-xs">
                        (Y: {hoveredNode.y.toFixed(0)})
                      </span>
                    </div>
                    <div className="space-y-1">
                      <div className="flex justify-between">
                        <span className="text-gray-400">Money:</span>
                        <span className="text-green-400 font-bold">
                           {(() => {
                            // Try to get actual values from parsed config
                            if (parsedConfig && hoveredNode.storyNodeType === 'event') {
                              // Find matching event data
                              const eventData = parsedConfig.events?.find((e: any) => {
                                // Match by various criteria
                                return e.nodeId === hoveredNode.id ||
                                       e.id === hoveredNode.id ||
                                       (e.name && hoveredNode.label?.includes(e.name));
                              });
                              if (eventData?.gold !== undefined) {
                                return eventData.gold.toLocaleString();
                              }
                            }

                            // Fallback to calculated values
                            const maxY = treeData?.nodes?.reduce((max, n) => Math.max(max, n.y), 0) || 850;
                            const minY = treeData?.nodes?.reduce((min, n) => Math.min(min, n.y), 850) || 0;
                            const progression = 1 - ((hoveredNode.y - minY) / (maxY - minY));

                            const baseMoney = hoveredNode.storyNodeType === 'final_boss' ? 1000000 :
                                             hoveredNode.storyNodeType === 'boss' ? 500000 :
                                             hoveredNode.storyNodeType === 'event' ? 300000 :
                                             hoveredNode.challenger ? 250000 : 150000;

                            const scaledMoney = Math.floor(baseMoney * (1 + progression * 2));
                            return scaledMoney.toLocaleString();
                          })()}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">XP:</span>
                        <span className="text-blue-400 font-bold">
                           {(() => {
                            // Try to get actual values from parsed config
                            if (parsedConfig && hoveredNode.storyNodeType === 'event') {
                              // Find matching event data
                              const eventData = parsedConfig.events?.find((e: any) => {
                                return e.nodeId === hoveredNode.id ||
                                       e.id === hoveredNode.id ||
                                       (e.name && hoveredNode.label?.includes(e.name));
                              });
                              if (eventData?.xp !== undefined) {
                                return eventData.xp.toLocaleString();
                              }
                            }

                            // Fallback to calculated values
                            const maxY = treeData?.nodes?.reduce((max, n) => Math.max(max, n.y), 0) || 850;
                            const minY = treeData?.nodes?.reduce((min, n) => Math.min(min, n.y), 850) || 0;
                            const progression = 1 - ((hoveredNode.y - minY) / (maxY - minY));

                            const baseXP = hoveredNode.storyNodeType === 'final_boss' ? 20000 :
                                          hoveredNode.storyNodeType === 'boss' ? 10000 :
                                          hoveredNode.storyNodeType === 'event' ? 7500 :
                                          hoveredNode.challenger ? 5000 : 3000;

                            const scaledXP = Math.floor(baseXP * (1 + progression * 1.5));
                            return scaledXP.toLocaleString();
                          })()}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Type:</span>
                        <span className="text-purple-400 font-bold">
                          {hoveredNode.storyNodeType === 'final_boss' ? ' Final Boss' :
                           hoveredNode.storyNodeType === 'boss' ? ' Boss' :
                           hoveredNode.storyNodeType === 'event' ? ' Event' :
                           hoveredNode.challenger ? ' Challenger' : ' Normal'}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">Progression:</span>
                        <span className="text-yellow-400">
                          {(() => {
                            const maxY = treeData?.nodes?.reduce((max, n) => Math.max(max, n.y), 0) || 850;
                            const minY = treeData?.nodes?.reduce((min, n) => Math.min(min, n.y), 850) || 0;
                            const progression = 1 - ((hoveredNode.y - minY) / (maxY - minY));
                            return `${(progression * 100).toFixed(1)}%`;
                          })()}
                        </span>
                      </div>
                    </div>

                    {/* Power Chip Rewards */}
                    {parsedConfig && hoveredNode.storyNodeType === 'event' && (() => {
                      const eventData = parsedConfig.events?.find((e: any) => {
                        return e.nodeId === hoveredNode.id ||
                               e.id === hoveredNode.id ||
                               (e.name && hoveredNode.label?.includes(e.name));
                      });
                      if (eventData?.chips && eventData.chips.length > 0) {
                        return (
                          <div className="mt-2 pt-2 border-t border-gray-700">
                            <div className="text-xs text-gray-400 mb-1">Power Chips:</div>
                            {eventData.chips.map((chip: any, idx: number) => (
                              <div key={idx} className="flex justify-between text-xs">
                                <span className="text-gray-300">{chip.type || chip.name}</span>
                                <span className="text-cyan-400">
                                  {chip.quantity || 1}x {chip.rarity || ''}
                                </span>
                              </div>
                            ))}
                          </div>
                        );
                      }
                      return null;
                    })()}

                    {hoveredNode.id && (
                      <div className="mt-2 pt-2 border-t border-gray-700">
                        <div className="text-xs text-gray-400">Node ID: {hoveredNode.id}</div>
                      </div>
                    )}
                  </div>
                </div>
              )}

              {/* Preview Mode Indicator */}
              {previewMode && (
                <div className="absolute top-4 left-4 z-30 bg-yellow-900/80 border border-yellow-500/50 rounded px-3 py-1">
                  <div className="text-yellow-400 font-bold text-xs uppercase tracking-wider">Preview Mode</div>
                  <div className="text-yellow-300 text-xs">Chapter {previewChapter} | Seed: {previewSeed}</div>
                </div>
              )}

              {/* Corner decorations - removed bottom left to not overlap with hemisphere */}
              <div className="absolute top-2 left-2 w-6 h-6 border-t-2 border-l-2 border-yellow-500/50" />
              <div className="absolute top-2 right-2 w-6 h-6 border-t-2 border-r-2 border-yellow-500/50" />
              <div className="absolute bottom-2 right-2 w-6 h-6 border-b-2 border-r-2 border-yellow-500/50" />
            </div>
            
            {/* Jump to Start Button */}
            {showJumpButton && !isJumping && (
              <button
                onClick={() => {
                  setIsJumping(true);
                  // Smooth animation to return to start position
                  const startOffset = viewportOffset;
                  const startPanY = panOffset.y;
                  const targetOffset = -250; // Original start position
                  const targetPanY = 0;
                  const duration = 800; // 800ms animation
                  const startTime = Date.now();
                  
                  const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    // Ease-in-out curve
                    const eased = progress < 0.5 
                      ? 2 * progress * progress 
                      : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    setViewportOffset(startOffset + (targetOffset - startOffset) * eased);
                    setPanOffset({ x: 0, y: startPanY + (targetPanY - startPanY) * eased });
                    
                    if (progress < 1) {
                      requestAnimationFrame(animate);
                    } else {
                      setIsJumping(false);
                    }
                  };
                  
                  requestAnimationFrame(animate);
                }}
                className="absolute top-32 left-1/3 transform -translate-x-1/2 px-3 py-1 bg-black/60 border border-yellow-500/40 rounded-md text-yellow-500 text-xs font-orbitron uppercase tracking-wider hover:bg-yellow-500/20 hover:border-yellow-500/60 transition-all duration-200 flex items-center gap-1 z-20 cursor-pointer"
                style={{
                  animation: 'fadeIn 0.3s ease-out forwards',
                }}
              >
                Jump Down
                <svg width="10" height="10" viewBox="0 0 12 12" fill="none" className="animate-bounce">
                  <path d="M6 2L6 9M6 9L3 6M6 9L9 6" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
                </svg>
              </button>
            )}
            
            {/* Easter Egg Text - shows when scrolled down below start */}
            {viewportOffset < -300 && (
              <div className="absolute -bottom-48 left-1/2 transform -translate-x-1/2 w-96 text-center text-gray-600 text-xs font-mono tracking-wide opacity-50"
                style={{
                  animation: 'fadeIn 1s ease-out forwards',
                }}>
                <p className="mb-2">// SYSTEM BREACH DETECTED //</p>
                <p className="mb-4 text-gray-700">Unauthorized access to restricted memory sector 0x7F3A9</p>
                <p className="text-gray-800 italic">
                  "The mechanisms remember what we have forgotten. 
                  Deep beneath the surface, where the roots of the tree 
                  extend into the void, lies the first protocol - 
                  the one that started it all. Some say it still whispers 
                  in binary, waiting for someone brave enough to decode 
                  its forgotten purpose."
                </p>
                <p className="mt-4 text-gray-600">// END TRANSMISSION //</p>
              </div>
            )}
            
          </div>

          {/* Right Column - Mission Card Details */}
          <div className="flex-grow pr-5">
            {/* Show card for selected node */}
            {selectedNode ? (
              <StoryMissionCard
                title={`Mission ${selectedNode.id}`}
                mekImage={getMekImage(selectedNode.id, true)}
                mekName={`MEK #${Math.floor(Math.random() * 9000) + 1000}`}
                mekRank={selectedNode.storyNodeType === 'final_boss' ? 100 :
                        selectedNode.storyNodeType === 'boss' ? 75 :
                        selectedNode.storyNodeType === 'event' ? 50 : 34}
                primaryReward={selectedNode.storyNodeType === 'final_boss' ? 1000000 :
                              selectedNode.storyNodeType === 'boss' ? 500000 :
                              selectedNode.storyNodeType === 'event' ? 300000 :
                              selectedNode.storyNodeType === 'normal' ? 150000 : 250000}
                experience={selectedNode.storyNodeType === 'final_boss' ? 20000 :
                           selectedNode.storyNodeType === 'boss' ? 10000 :
                           selectedNode.storyNodeType === 'event' ? 7500 :
                           selectedNode.storyNodeType === 'normal' ? 3000 : 5000}
                potentialRewards={getNodeRewards(selectedNode as ExtendedStoryNode)}
                variationBuffs={getNodeVariationBuffs(selectedNode as ExtendedStoryNode)}
                successChance={completedNodes.has(selectedNode.id) ? 100 :
                              isNodeAvailable(selectedNode) ?
                                calculateSuccessChance(
                                  selectedNode.id,
                                  65,
                                  getNodeVariationBuffs(selectedNode as ExtendedStoryNode)
                                ) : 0}
                deploymentFee={selectedNode.storyNodeType === 'final_boss' ? 200000 :
                              selectedNode.storyNodeType === 'boss' ? 100000 :
                              selectedNode.storyNodeType === 'event' ? 75000 :
                              selectedNode.storyNodeType === 'normal' ? 30000 : 50000}
                availableSlots={getNodeAvailableSlots(selectedNode as ExtendedStoryNode)}
                selectedMeks={selectedMeks[selectedNode.id] || []}
                onDeploy={() => handleNodeDeploy(selectedNode as ExtendedStoryNode)}
                onMekSlotClick={handleMekSlotClick}
                onMekRemove={handleMekRemove}
                scale={0.95}
                isLocked={!isNodeAvailable(selectedNode) && !completedNodes.has(selectedNode.id)}
              />
            ) : (
              // No node selected or hovered - Using Style K from UI Showcase
              <StyleK className="h-full flex items-center justify-center">
                <div className="text-center">
                  <h3 className="text-2xl font-orbitron font-bold text-yellow-500 mb-3 uppercase tracking-wider">Select A Node</h3>
                  <p className="text-gray-400 text-sm">
                    Click any available node to view mission details
                  </p>

                  <div className="mt-8 text-xs text-gray-500">
                    <p>Progress: {completedNodes.size} / {treeData?.nodes.length || 0} Nodes</p>
                  </div>
                </div>
              </StyleK>
            )}

            {/* Complete button - outside the card for easy removal later */}
            {selectedNode && isNodeAvailable(selectedNode) && !completedNodes.has(selectedNode.id) && (
              <div className="mt-4 px-4">
                <button
                  onClick={() => {
                    const newCompleted = new Set(completedNodes);
                    newCompleted.add(selectedNode.id);
                    setCompletedNodes(newCompleted);
                    setSelectedNode(null); // Clear selection after completing
                  }}
                  className="w-full px-6 py-3 bg-green-600 hover:bg-green-500 text-white font-bold uppercase tracking-wider transition-colors duration-200 border-2 border-green-400/50"
                  style={{ clipPath: 'polygon(0 0, calc(100% - 10px) 0, 100% 100%, 10px 100%)' }}
                >
                  Complete Mission
                </button>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Mek Recruitment Modal */}
      <MekRecruitmentModalV4
        showMekModal={showMekModal}
        selectedMekSlot={selectedMekSlot}
        onClose={() => {
          setShowMekModal(null);
          setSelectedMekSlot(null);
        }}
        onMekSelection={handleMekSelection}
        mekCount={40}
        mekCardStyle={1}
        traitCircleStyle={1}
        mekFrameStyle={1}
      />
    </div>
  );
}