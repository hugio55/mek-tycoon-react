/**
 * NMKR Metadata Generator
 *
 * Generates CIP-25 compliant .metadata JSON files for NMKR Studio bulk upload
 *
 * NMKR Workflow:
 * 1. Upload single artwork image (bronze.png) to NMKR
 * 2. Upload multiple .metadata files generated by this tool
 * 3. NMKR creates multiple NFTs all pointing to same IPFS image hash
 */

export interface NMKRMetadataParams {
  collectionName?: string;      // DEPRECATED: Use customFields with 'Collection' instead
  displayNameBase: string;      // "Bronze Token" (display name with spaces - shown on pool.pm)
  tokenBaseName: string;        // "MekBetaBronzeToken" (on-chain asset name - no spaces/special chars)
  numberOfNFTs: number;         // 5, 35, 100, etc.
  phase: number;                // 1, 2, 3...
  description: string;          // Description template (max 64 chars)
  policyId: string;             // Cardano policy ID (hex string)
  imageIpfsHash?: string;       // Optional: "QmXxxx..." or leave empty for NMKR to fill
  customFields?: Array<{name: string; value: string | number}>;  // Dynamic custom metadata fields
  website?: string;             // Website URL (defaults to 'https://mektycoon.com')
  artist?: string;              // DEPRECATED: Use customFields instead
  company?: string;             // DEPRECATED: Use customFields instead
  game?: string;                // DEPRECATED: Use customFields instead
}

export interface NMKRMetadataFile {
  filename: string;    // "Bronze Token #1.metadata"
  content: string;     // JSON string
}

/**
 * Generate NMKR-compatible metadata files
 *
 * Creates N metadata JSON files ready for NMKR Studio drag-and-drop upload
 *
 * @param params - Metadata generation parameters
 * @returns Array of {filename, content} objects
 */
export function generateNMKRMetadataFiles(params: NMKRMetadataParams): NMKRMetadataFile[] {
  const files: NMKRMetadataFile[] = [];

  for (let i = 1; i <= params.numberOfNFTs; i++) {
    const metadata = buildSingleNFTMetadata(params, i);
    // Filename uses display name with spaces and number - this becomes the display name in NMKR
    const filename = `${params.displayNameBase} #${i}.metadata`;
    const content = JSON.stringify(metadata, null, 2);

    files.push({ filename, content });
  }

  return files;
}

/**
 * Build metadata for a single NFT
 *
 * Returns FULL CIP-25 structure with NMKR placeholders:
 * {
 *   "721": {
 *     "<policy_id>": {
 *       "<asset_name>": {
 *         "name": "<display_name>",
 *         "image": "<ipfs_link>",
 *         "mediaType": "<mime_type>",
 *         ...custom fields...
 *       }
 *     },
 *     "version": "1.0"
 *   }
 * }
 *
 * NMKR replaces placeholders like <policy_id>, <asset_name>, <ipfs_link>, <mime_type>
 * during minting with actual values from uploaded files.
 */
function buildSingleNFTMetadata(params: NMKRMetadataParams, editionNumber: number) {
  // Build inner metadata object with required CIP-25 fields
  // Use NMKR placeholders that get replaced during minting
  const innerMetadata: Record<string, any> = {
    name: `<display_name>`,  // NMKR uses display name from filename
    image: `<ipfs_link>`,     // NMKR fills from uploaded image
    mediaType: `<mime_type>`, // NMKR detects from uploaded file
    description: params.description
  }

  // Add custom fields in order they were defined
  if (params.customFields && params.customFields.length > 0) {
    params.customFields.forEach(field => {
      innerMetadata[field.name] = field.value;
    });
  } else {
    // Legacy fallback: Use old hardcoded fields for backwards compatibility
    innerMetadata.Collection = params.collectionName;
    innerMetadata.Game = params.game || 'Mek Tycoon';
    innerMetadata.Artist = params.artist || 'Wren Ellis';
    innerMetadata.Company = params.company || 'Over Exposed';
    innerMetadata.Phase = params.phase;
  }

  // Website goes last (use param or default)
  innerMetadata.website = params.website || 'https://mektycoon.com';

  // Wrap in full CIP-25 structure with NMKR placeholders
  return {
    "721": {
      "<policy_id>": {
        "<asset_name>": innerMetadata
      },
      "version": "1.0"
    }
  };
}

/**
 * Infer media type from image URL
 */
function inferMediaType(url: string): string {
  const lower = url.toLowerCase();

  if (lower.includes('placeholder')) return 'image/png';
  if (lower.endsWith('.png')) return 'image/png';
  if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
  if (lower.endsWith('.gif')) return 'image/gif';
  if (lower.endsWith('.webp')) return 'image/webp';
  if (url.startsWith('ipfs://')) return 'image/png';

  return 'image/png';
}

/**
 * Get description template for a phase
 */
export function getDefaultDescription(phase: number, collectionName: string): string {
  return `Commemorative NFT for Phase ${phase} beta testers of Mek Tycoon.`;
}

/**
 * Validate metadata parameters
 */
export function validateMetadataParams(params: NMKRMetadataParams): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  // collectionName is no longer required - custom fields handle this

  if (!params.displayNameBase || params.displayNameBase.trim() === '') {
    errors.push('Display name base is required');
  }

  if (!params.tokenBaseName || params.tokenBaseName.trim() === '') {
    errors.push('Token base name is required');
  }

  if (params.numberOfNFTs < 1 || params.numberOfNFTs > 1000) {
    errors.push('Number of NFTs must be between 1 and 1000');
  }

  if (params.phase < 1) {
    errors.push('Phase must be at least 1');
  }

  if (!params.description || params.description.trim() === '') {
    errors.push('Description is required');
  }

  if (params.description.length > 63) {
    errors.push('Description must be 63 characters or less (NMKR limit)');
  }

  if (!params.policyId || params.policyId.trim() === '') {
    errors.push('Policy ID is required');
  }

  // Validate policy ID format (hex string, typically 56 chars)
  if (params.policyId && !/^[0-9a-fA-F]{56}$/.test(params.policyId.trim())) {
    errors.push('Policy ID must be a 56-character hexadecimal string');
  }

  // Validate IPFS hash format (if provided)
  if (params.imageIpfsHash) {
    const cleaned = params.imageIpfsHash.trim();
    if (cleaned.startsWith('http://') || cleaned.startsWith('https://')) {
      errors.push('Image IPFS Hash should be CID only (QmXxxx or bafybeif...), not full URL');
    } else if (!cleaned.startsWith('Qm') && !cleaned.startsWith('bafy')) {
      errors.push('Image IPFS Hash must be valid CID (start with Qm or bafy)');
    }
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

/**
 * Format filename for download
 */
export function getDownloadFilename(tokenBaseName: string): string {
  const sanitized = tokenBaseName.replace(/[^a-zA-Z0-9]/g, '');
  return `${sanitized}_metadata.zip`;
}
