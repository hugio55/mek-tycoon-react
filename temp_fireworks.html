<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Northstar Fireworks</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Quicksand:wght@300;400&family=Montserrat:wght@300;400&family=Playfair+Display:wght@400&family=Oswald:wght@300&family=Bebas+Neue&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            cursor: auto; /* Show default cursor by default */
            position: relative;
            font-family: 'Quicksand', sans-serif;
        }
        
        body.hide-cursor {
            cursor: none;
        }
        
        /* Custom cursor */
        #cursor {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: screen;
        }
        
        .crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            display: none;
        }
        
        .crosshair.visible {
            display: block;
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        
        .crosshair::before {
            width: 1px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .crosshair::after {
            width: 20px;
            height: 1px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .crosshair-circle {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        #sparkler-canvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 9998;
        }
        
        /* Canvases */
        #stars-canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .background-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            object-fit: cover;
        }
        
        .middle-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            object-fit: cover;
            pointer-events: none;
        }
        
        #fireworks-canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 3;
        }
        
        #reflection-canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 5;
            pointer-events: none;
            opacity: 0.6;
        }
        
        .water-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 6;
            object-fit: cover;
            pointer-events: none;
            mix-blend-mode: normal;
            opacity: 0.9;
        }
        
        /* Controls */
        .controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: block;
        }
        
        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-group label {
            color: white;
            font-size: 12px;
            width: 100px;
        }
        
        .control-group select {
            padding: 5px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        /* Branding */
        .branding-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 15;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .brand-logo {
            width: 200px;
            opacity: 0.9;
        }
        
        /* Logo effects - static glows */
        .logo-effect-1 {
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.6)) drop-shadow(0 0 40px rgba(255, 215, 0, 0.3));
        }
        
        .logo-effect-2 {
            filter: drop-shadow(0 0 25px rgba(255, 100, 200, 0.7)) drop-shadow(0 0 50px rgba(100, 50, 255, 0.4));
        }
        
        .logo-effect-3 {
            filter: drop-shadow(0 0 30px rgba(100, 255, 100, 0.6)) drop-shadow(0 0 60px rgba(50, 200, 50, 0.3));
        }
        
        .logo-effect-4 {
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.8)) drop-shadow(0 0 30px rgba(200, 200, 255, 0.5)) drop-shadow(0 0 45px rgba(150, 150, 255, 0.3));
        }
        
        .logo-effect-5 {
            filter: drop-shadow(0 0 20px rgba(255, 150, 50, 0.7)) drop-shadow(0 0 40px rgba(255, 100, 0, 0.4)) drop-shadow(0 0 60px rgba(200, 50, 0, 0.2));
        }
        
        .logo-effect-6 {
            filter: drop-shadow(0 0 35px rgba(200, 100, 255, 0.6)) contrast(1.2) brightness(1.1);
        }
        
        .logo-effect-7 {
            filter: drop-shadow(0 0 25px rgba(255, 215, 0, 0.5)) drop-shadow(0 0 50px rgba(255, 100, 0, 0.3)) saturate(1.3);
        }
        
        .logo-effect-8 {
            filter: drop-shadow(0 0 20px rgba(100, 200, 255, 0.7)) drop-shadow(0 0 40px rgba(50, 150, 255, 0.4)) hue-rotate(20deg);
        }
        
        .enter-button {
            padding: 10px 25px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            letter-spacing: 2px;
            text-transform: uppercase;
            transition: all 0.3s;
            color: white;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 120px;
            height: 45px;
        }
        
        /* Button Style 1 - Frosted Glass with Particles */
        .button-style-1 {
            font-family: 'Montserrat', sans-serif;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .button-style-1::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.3), transparent);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
            border-radius: 50%;
        }
        
        .button-style-1:hover::before {
            width: 100%;
            height: 100%;
        }
        
        .button-style-1:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 8px 30px rgba(255, 255, 255, 0.2);
        }
        
        /* Button Style 2 - Crystal Prism */
        .button-style-2 {
            font-family: 'Bebas Neue', sans-serif;
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.1) 0%, 
                rgba(255, 255, 255, 0.05) 50%, 
                rgba(255, 255, 255, 0.1) 100%);
            backdrop-filter: blur(15px);
            border: 2px solid transparent;
            background-clip: padding-box;
            box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.1),
                0 10px 40px rgba(0, 0, 0, 0.5);
            text-shadow: 0 3px 5px rgba(0, 0, 0, 0.9);
            transform-style: preserve-3d;
            transition: all 0.4s;
        }
        
        .button-style-2:hover {
            box-shadow: 
                inset 0 0 30px rgba(255, 255, 255, 0.2),
                0 15px 50px rgba(100, 100, 255, 0.3);
        }
        
        /* Button Style 3 - Smoke Glass */
        .button-style-3 {
            font-family: 'Playfair Display', serif;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(8px) contrast(1.2);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            text-shadow: 0 2px 8px rgba(0, 0, 0, 1);
            position: relative;
        }
        
        .button-style-3::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent,
                rgba(255, 255, 255, 0.03),
                transparent
            );
            transform: rotate(45deg);
            transition: all 0.6s;
            opacity: 0;
        }
        
        .button-style-3:hover::after {
            opacity: 1;
        }
        
        .button-style-3:hover {
            background: rgba(255, 255, 255, 0.06);
        }
        
        /* Button Style 4 - Aurora Glass */
        .button-style-4 {
            font-family: 'Oswald', sans-serif;
            font-weight: 300;
            background: rgba(255, 255, 255, 0.04);
            backdrop-filter: blur(12px) hue-rotate(0deg);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.7);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            transition: all 0.5s;
        }
        
        .button-style-4:hover {
            backdrop-filter: blur(10px) hue-rotate(90deg);
            background: linear-gradient(90deg, 
                rgba(255, 100, 100, 0.1),
                rgba(100, 255, 100, 0.1),
                rgba(100, 100, 255, 0.1)
            );
            border-color: rgba(255, 255, 255, 0.3);
            animation: aurora 3s linear infinite;
        }
        
        @keyframes aurora {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        
        /* Button Style 5 - Particle Storm */
        .button-style-5 {
            font-family: 'Quicksand', sans-serif;
            background: rgba(255, 255, 255, 0.04);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .button-style-5 canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .button-style-5:hover canvas {
            opacity: 1;
        }
        
        .button-style-5:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.25);
        }
    </style>
</head>
<body>
    <!-- Custom cursor -->
    <div id="cursor">
        <div class="crosshair">
            <div class="crosshair-circle"></div>
        </div>
    </div>
    <canvas id="sparkler-canvas"></canvas>
    
    <!-- Water effect filter -->
    <div style="position: fixed; width: 0; height: 0;">
        <svg>
            <defs>
                <filter id="water">
                    <feTurbulence baseFrequency="0.01 0.02" numOctaves="1" seed="2" />
                    <feDisplacementMap in="SourceGraphic" scale="3" />
                </filter>
            </defs>
        </svg>
    </div>
    
    <div class="controls">
        <div class="control-group">
            <label for="button-style">Button Style:</label>
            <select id="button-style">
                <option value="button-style-1">Frosted Particle</option>
                <option value="button-style-2">Crystal Prism</option>
                <option value="button-style-3">Smoke Glass</option>
                <option value="button-style-4">Aurora Glass</option>
                <option value="button-style-5">Particle Storm</option>
            </select>
        </div>
        <div class="control-group">
            <label for="logo-effect">Logo Effect:</label>
            <select id="logo-effect">
                <option value="logo-effect-1">Golden Aura</option>
                <option value="logo-effect-2">Purple Nebula</option>
                <option value="logo-effect-3">Emerald Glow</option>
                <option value="logo-effect-4">Crystal White</option>
                <option value="logo-effect-5">Sunset Orange</option>
                <option value="logo-effect-6">Violet Dream</option>
                <option value="logo-effect-7">Fire Burst</option>
                <option value="logo-effect-8">Ocean Blue</option>
            </select>
        </div>
        <div class="control-group">
            <label for="flash-style">Flash Intensity:</label>
            <select id="flash-style">
                <option value="screen-low">Screen - Subtle</option>
                <option value="screen" selected>Screen - Medium</option>
                <option value="screen-high">Screen - Intense</option>
            </select>
        </div>
        <div class="control-group">
            <label for="firework-type">Firework Type:</label>
            <select id="firework-type">
                <option value="random">Random Mix</option>
                <option value="classic">Classic</option>
                <option value="willow">Willow</option>
                <option value="chrysanthemum">Chrysanthemum</option>
                <option value="palm">Palm</option>
                <option value="glitter">Glitter</option>
                <option value="crackle">Crackle</option>
                <option value="mosquito">Mosquito</option>
            </select>
        </div>
    </div>
    
    <!-- Stars -->
    <canvas id="stars-canvas"></canvas>
    
    <!-- Background -->
    <img src="./BG images/back 1.webp" class="background-layer" id="back-layer">
    
    <!-- Fireworks -->
    <canvas id="fireworks-canvas"></canvas>
    
    <!-- Middle silhouette -->
    <img src="./BG images/middle 1.webp" class="middle-layer">
    
    <!-- Reflection -->
    <canvas id="reflection-canvas"></canvas>
    
    <!-- Water -->
    <img src="./BG images/top 2.webp" class="water-layer">
    
    <!-- Branding -->
    <div class="branding-container" id="branding">
        <img src="./Northstar-Fireworks-Logo.png" alt="Northstar Fireworks" class="brand-logo logo-effect-1" id="logo">
        <button class="enter-button button-style-1" id="enter-btn">
            <span style="position: relative; z-index: 1;">Enter</span>
        </button>
    </div>
    
    <!-- Audio -->
    <audio id="boom-audio" src="./sounds/boom.mp3" preload="auto"></audio>
    
    <script>
        // Cursor effect without sparkler particles
        const cursor = document.getElementById('cursor');
        const crosshair = cursor.querySelector('.crosshair');
        const backLayer = document.getElementById('back-layer');
        let mouseX = 0;
        let mouseY = 0;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            cursor.style.left = mouseX + 'px';
            cursor.style.top = mouseY + 'px';
            
            // Check if mouse is over background layer (for crosshair)
            const rect = backLayer.getBoundingClientRect();
            const overBackground = mouseX >= rect.left && mouseX <= rect.right && 
                                  mouseY >= rect.top && mouseY <= rect.bottom;
            
            if (overBackground) {
                crosshair.classList.add('visible');
                document.body.classList.add('hide-cursor');
            } else {
                crosshair.classList.remove('visible');
                document.body.classList.remove('hide-cursor');
            }
        });
        
        
        // Controls
        const buttonSelect = document.getElementById('button-style');
        const logoSelect = document.getElementById('logo-effect');
        const flashSelect = document.getElementById('flash-style');
        const fireworkSelect = document.getElementById('firework-type');
        const enterBtn = document.getElementById('enter-btn');
        const logo = document.getElementById('logo');
        
        let currentFlashStyle = 'screen';
        
        buttonSelect.addEventListener('change', (e) => {
            enterBtn.className = `enter-button ${e.target.value}`;
        });
        
        logoSelect.addEventListener('change', (e) => {
            logo.className = `brand-logo ${e.target.value}`;
        });
        
        flashSelect.addEventListener('change', (e) => {
            currentFlashStyle = e.target.value;
        });
        
        
        // Canvases
        const canvas = document.getElementById('fireworks-canvas');
        const ctx = canvas.getContext('2d');
        const reflectionCanvas = document.getElementById('reflection-canvas');
        const reflectionCtx = reflectionCanvas.getContext('2d');
        const starsCanvas = document.getElementById('stars-canvas');
        const starsCtx = starsCanvas.getContext('2d');
        
        function resizeCanvases() {
            canvas.width = reflectionCanvas.width = starsCanvas.width = window.innerWidth;
            canvas.height = reflectionCanvas.height = starsCanvas.height = window.innerHeight;
        }
        
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);
        
        // Launch point
        const LAUNCH_X = window.innerWidth / 2;
        const LAUNCH_Y = window.innerHeight * 0.55;
        const WATER_LINE = window.innerHeight * 0.58;
        
        // Stars with more near horizon
        const stars = [];
        const shootingStars = [];
        
        function createStars() {
            stars.length = 0;
            const starCount = 250;
            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight * 0.55,
                    size: i < 180 ? Math.random() * 2 : Math.random() * 1,
                    opacity: Math.random() * 1.0 + 0.5,
                    twinkle: Math.random() * Math.PI * 2,
                    twinkleSpeed: 0.03 + Math.random() * 0.05
                });
            }
        }
        
        createStars();
        
        function drawStars() {
            starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
            
            // Draw twinkling stars with 25% more effectiveness
            stars.forEach(star => {
                star.twinkle += star.twinkleSpeed;
                const flicker = Math.sin(star.twinkle) * 1.0 + 1.0;
                const actualOpacity = star.opacity * flicker;
                
                starsCtx.save();
                starsCtx.globalAlpha = actualOpacity;
                starsCtx.fillStyle = '#ffffff';
                starsCtx.beginPath();
                starsCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                starsCtx.fill();
                starsCtx.restore();
            });
            
            // Fast shooting stars
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const star = shootingStars[i];
                star.x += star.vx;
                star.y += star.vy;
                star.life -= 0.015;
                
                if (star.life > 0 && star.x > -200 && star.x < canvas.width + 200) {
                    starsCtx.save();
                    starsCtx.globalAlpha = star.life;
                    
                    // Draw bright trail
                    const gradient = starsCtx.createLinearGradient(
                        star.x - star.vx * 10, star.y - star.vy * 10,
                        star.x, star.y
                    );
                    gradient.addColorStop(0, 'transparent');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 1)');
                    
                    starsCtx.strokeStyle = gradient;
                    starsCtx.lineWidth = 2;
                    starsCtx.beginPath();
                    starsCtx.moveTo(star.x - star.vx * 15, star.y - star.vy * 15);
                    starsCtx.lineTo(star.x, star.y);
                    starsCtx.stroke();
                    
                    // Draw star head
                    starsCtx.fillStyle = '#ffffff';
                    starsCtx.fillRect(star.x - 1, star.y - 1, 2, 2);
                    
                    starsCtx.restore();
                } else {
                    shootingStars.splice(i, 1);
                }
            }
        }
        
        // Create shooting stars with round robin spawning
        let lastShootingStarSide = null;
        let shootingStarSpawnPoints = [
            { side: 'left-top', used: false },
            { side: 'left-mid', used: false },
            { side: 'right-top', used: false },
            { side: 'right-mid', used: false },
            { side: 'top-left', used: false },
            { side: 'top-right', used: false }
        ];
        
        setInterval(() => {
            if (Math.random() > 0.7 && shootingStars.length < 2) {
                // Round robin spawn point selection
                const availablePoints = shootingStarSpawnPoints.filter(p => !p.used);
                if (availablePoints.length === 0) {
                    shootingStarSpawnPoints.forEach(p => p.used = false);
                }
                
                const spawnPoint = shootingStarSpawnPoints.find(p => !p.used && p.side !== lastShootingStarSide);
                if (!spawnPoint) return;
                
                spawnPoint.used = true;
                lastShootingStarSide = spawnPoint.side;
                
                let x, y, vx, vy;
                const baseSpeed = 8 + Math.random() * 4.8; // 20% faster max
                const angle = Math.PI / 6 + Math.random() * Math.PI / 3;
                
                switch(spawnPoint.side) {
                    case 'left-top':
                        x = -100;
                        y = Math.random() * canvas.height * 0.15;
                        vx = Math.cos(angle) * baseSpeed;
                        vy = Math.sin(angle) * baseSpeed * 0.3;
                        break;
                    case 'left-mid':
                        x = -100;
                        y = canvas.height * 0.15 + Math.random() * canvas.height * 0.15;
                        vx = Math.cos(angle) * baseSpeed;
                        vy = Math.sin(angle) * baseSpeed * 0.3;
                        break;
                    case 'right-top':
                        x = canvas.width + 100;
                        y = Math.random() * canvas.height * 0.15;
                        vx = -Math.cos(angle) * baseSpeed;
                        vy = Math.sin(angle) * baseSpeed * 0.3;
                        break;
                    case 'right-mid':
                        x = canvas.width + 100;
                        y = canvas.height * 0.15 + Math.random() * canvas.height * 0.15;
                        vx = -Math.cos(angle) * baseSpeed;
                        vy = Math.sin(angle) * baseSpeed * 0.3;
                        break;
                    case 'top-left':
                        x = Math.random() * canvas.width * 0.4;
                        y = -50;
                        vx = Math.cos(angle) * baseSpeed * 0.5;
                        vy = Math.sin(angle) * baseSpeed;
                        break;
                    case 'top-right':
                        x = canvas.width * 0.6 + Math.random() * canvas.width * 0.4;
                        y = -50;
                        vx = -Math.cos(angle) * baseSpeed * 0.5;
                        vy = Math.sin(angle) * baseSpeed;
                        break;
                }
                
                shootingStars.push({
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    life: 1
                });
            }
        }, 6000); // 50% less frequent
        
        // Particles
        const particles = [];
        const rockets = [];
        const gravity = 0.0375;
        const friction = 0.996;
        const MAX_PARTICLES = 2000;
        const MAX_ROCKETS = 100;
        
        // Trail particles - limit for performance
        const trailParticles = [];
        const MAX_TRAIL_PARTICLES = 150;
        
        class TrailParticle {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 1;
                this.size = Math.random() * 1.5 + 0.5;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.96;
                this.vy *= 0.96;
                this.vy += gravity * 0.5;
                this.life -= 0.04;
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life * 0.6;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.restore();
            }
        }
        
        class Particle {
            constructor(x, y, vx, vy, color, size = 2, trail = true, type = 'normal') {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.size = size;
                this.alpha = 1;
                this.trail = trail;
                this.history = [];
                this.maxHistory = trail ? 10 : 0;
                this.life = 1;
                this.type = type;
                this.glitter = type === 'glitter' ? Math.random() * Math.PI * 2 : 0;
            }
            
            update() {
                if (this.trail && this.alpha > 0.2 && this.maxHistory > 0) {
                    this.history.push({ x: this.x, y: this.y });
                    if (this.history.length > this.maxHistory) {
                        this.history.shift();
                    }
                }
                
                if (this.type === 'willow') {
                    this.vx *= 0.99;
                    this.vy *= 0.99;
                    this.vy += gravity * 2;
                    this.life -= 0.001;
                } else if (this.type === 'palm') {
                    this.vx *= 0.985;
                    this.vy *= 0.985;
                    this.vy += gravity * 1.5;
                    this.life -= 0.002;
                } else if (this.type === 'crackle') {
                    this.vx += (Math.random() - 0.5) * 0.3;
                    this.vy += (Math.random() - 0.5) * 0.3;
                    this.vx *= 0.95;
                    this.vy *= 0.95;
                    this.life -= 0.015;
                } else {
                    this.vx *= friction;
                    this.vy *= friction;
                    this.vy += gravity;
                    this.life -= 0.0025;
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.alpha = Math.max(0, this.life);
                
                if (this.type === 'glitter') {
                    this.glitter += 0.1;
                    this.size = 2 + Math.sin(this.glitter) * 1.5;
                }
                
                return this.alpha > 0 && this.y < canvas.height + 50;
            }
            
            draw() {
                if (this.alpha <= 0) return;
                
                ctx.save();
                
                if (this.trail && this.history.length > 1 && this.alpha > 0.1) {
                    if (this.type === 'willow' || this.type === 'palm') {
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        for (let i = 0; i < this.history.length - 1; i++) {
                            const point = this.history[i];
                            const nextPoint = this.history[i + 1];
                            ctx.globalAlpha = (i / this.history.length) * this.alpha * 0.5;
                            ctx.moveTo(point.x, point.y);
                            ctx.lineTo(nextPoint.x, nextPoint.y);
                        }
                        ctx.stroke();
                    } else {
                        // Skip some points for performance
                        for (let i = this.history.length - 1; i >= 0; i -= 2) {
                            const point = this.history[i];
                            const trailAlpha = (i / this.history.length) * this.alpha * 0.3;
                            if (trailAlpha > 0.05) {
                                ctx.globalAlpha = trailAlpha;
                                ctx.fillStyle = this.color;
                                ctx.fillRect(point.x - 1, point.y - 1, 2, 2);
                            }
                        }
                    }
                }
                
                ctx.globalAlpha = this.alpha;
                // Reduce shadows for performance
                if (this.type === 'glitter' && this.alpha > 0.5) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                } else if (this.type === 'crackle' && this.alpha > 0.7) {
                    ctx.shadowBlur = 3;
                    ctx.shadowColor = '#FFF';
                }
                
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                
                ctx.restore();
            }
        }
        
        class Rocket {
            constructor(targetX, targetY) {
                this.x = LAUNCH_X;
                this.y = LAUNCH_Y;
                this.targetX = targetX;
                this.targetY = targetY;
                
                // Improved trajectory calculation
                const dx = targetX - LAUNCH_X;
                const dy = targetY - LAUNCH_Y;
                
                // Calculate flight time based on distance
                const distance = Math.sqrt(dx * dx + dy * dy);
                const horizontalDist = Math.abs(dx);
                const verticalDist = Math.abs(dy);
                
                // Adjust flight time based on click position
                let flightTime;
                if (horizontalDist > canvas.width * 0.35) {
                    // Far edge clicks need more horizontal velocity
                    flightTime = 35 + (horizontalDist / 25);
                } else {
                    flightTime = 40 + (distance / 20);
                }
                
                // Calculate velocities with better physics
                this.vx = dx / flightTime;
                
                // Adjust vertical velocity for far edge clicks
                if (horizontalDist > canvas.width * 0.35) {
                    // Less vertical velocity for far clicks
                    this.vy = (dy / flightTime) - (gravity * flightTime * 0.35);
                } else {
                    this.vy = (dy / flightTime) - (gravity * flightTime * 0.5);
                }
                
                // Apply reasonable limits
                this.vx = Math.max(-8, Math.min(8, this.vx));
                this.vy = Math.max(-12, Math.min(-2, this.vy));
                
                this.trail = [];
                this.exploded = false;
                this.sparkTimer = 0;
                this.windOffset = 0;
            }
            
            update() {
                if (this.exploded) return true;
                
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 20) {
                    this.trail.shift();
                }
                
                this.vx *= 0.999;
                this.vy += gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                this.windOffset = Math.sin(this.y * 0.01) * 2;
                
                this.sparkTimer++;
                if (this.sparkTimer % 2 === 0) {
                    for (let i = 0; i < 3; i++) {
                        const spark = new TrailParticle(
                            this.x + (Math.random() - 0.5) * 4,
                            this.y + (Math.random() - 0.5) * 4,
                            (Math.random() - 0.5) * 2,
                            Math.random() * 2 + 1,
                            '#FFA500'
                        );
                        if (trailParticles.length < MAX_TRAIL_PARTICLES) {
                            trailParticles.push(spark);
                        }
                    }
                }
                
                // Check if rocket should explode
                const shouldExplode = this.vy >= 0 || 
                                    this.y <= this.targetY ||
                                    (Math.abs(this.x - this.targetX) < 20 && Math.abs(this.y - this.targetY) < 30);
                
                if (shouldExplode) {
                    this.explode();
                }
                
                return true;
            }
            
            explode() {
                if (this.exploded) return;
                this.exploded = true;
                
                playExplosionSound();
                
                const type = fireworkSelect.value;
                const colors = [
                    '#FFD700', '#FFA500', '#FF6347', '#FF1493', 
                    '#00CED1', '#7FFF00', '#FF69B4', '#F0E68C',
                    '#9370DB', '#FF4500', '#00FF00', '#1E90FF'
                ];
                const mainColor = colors[Math.floor(Math.random() * colors.length)];
                
                // Enhanced flash effect with intensity variations
                const flash = document.createElement('div');
                
                let opacity, radius;
                switch(currentFlashStyle) {
                    case 'screen-low':
                        opacity = '33'; // 20%
                        radius = 600;
                        break;
                    case 'screen-high':
                        opacity = '99'; // 60%
                        radius = 1000;
                        break;
                    default: // screen medium
                        opacity = '66'; // 40%
                        radius = 800;
                }
                
                flash.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: radial-gradient(circle ${radius}px at ${this.x}px ${this.y}px, 
                        ${mainColor}${opacity}, transparent 60%);
                    pointer-events: none;
                    z-index: 8;
                    mix-blend-mode: screen;
                    animation: flashBurst 1s ease-out;
                `;
                
                if (!document.querySelector('#flash-burst-style')) {
                    const style = document.createElement('style');
                    style.id = 'flash-burst-style';
                    style.textContent = `
                        @keyframes flashBurst {
                            0% { opacity: 0; transform: scale(0.5); }
                            10% { opacity: 1; transform: scale(1); }
                            100% { opacity: 0; transform: scale(1.2); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 1000);
                
                let selectedType = type;
                if (type === 'random') {
                    const types = ['classic', 'willow', 'glitter', 'crackle', 'chrysanthemum', 'palm', 'mosquito'];
                    selectedType = types[Math.floor(Math.random() * types.length)];
                }
                
                // Dense explosions
                switch (selectedType) {
                    case 'willow':
                        for (let i = 0; i < 150; i++) {
                            const angle = (Math.PI * 2 / 150) * i;
                            const velocity = 1 + Math.random() * 0.5;
                            particles.push(new Particle(
                                this.x, this.y,
                                Math.cos(angle) * velocity,
                                Math.sin(angle) * velocity - 0.5,
                                '#FFD700',
                                2.5,
                                true,
                                'willow'
                            ));
                        }
                        break;
                        
                    case 'crackle':
                        // Ring
                        for (let i = 0; i < 100; i++) {
                            const angle = (Math.PI * 2 / 100) * i;
                            const velocity = 2 + Math.random();
                            particles.push(new Particle(
                                this.x, this.y,
                                Math.cos(angle) * velocity,
                                Math.sin(angle) * velocity - 0.5,
                                mainColor,
                                1.5,
                                true,
                                'normal'
                            ));
                        }
                        // Crackle sparks
                        for (let i = 0; i < 50; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const velocity = 1 + Math.random() * 2;
                            particles.push(new Particle(
                                this.x, this.y,
                                Math.cos(angle) * velocity,
                                Math.sin(angle) * velocity,
                                '#FFF',
                                1,
                                false,
                                'crackle'
                            ));
                        }
                        // Fill
                        for (let i = 0; i < 40; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const velocity = Math.random() * 2;
                            particles.push(new Particle(
                                this.x, this.y,
                                Math.cos(angle) * velocity,
                                Math.sin(angle) * velocity - 0.5,
                                mainColor,
                                1.5,
                                true,
                                'normal'
                            ));
                        }
                        break;
                        
                    case 'palm':
                        const palmColors = ['#FFD700', '#FFA500', '#FF6347'];
                        for (let j = 0; j < 6; j++) {
                            const baseAngle = (Math.PI * 2 / 6) * j;
                            const color = palmColors[j % palmColors.length];
                            for (let i = 0; i < 20; i++) {
                                const angle = baseAngle + (Math.random() - 0.5) * 0.3;
                                const velocity = 3 + Math.random();
                                particles.push(new Particle(
                                    this.x, this.y,
                                    Math.cos(angle) * velocity,
                                    Math.sin(angle) * velocity - 1,
                                    color,
                                    3,
                                    true,
                                    'palm'
                                ));
                            }
                        }
                        break;
                        
                    case 'chrysanthemum':
                        for (let i = 0; i < 200; i++) {
                            const angle = (Math.PI * 2 / 200) * i;
                            const velocity = 2.5 + Math.random() * 0.5;
                            particles.push(new Particle(
                                this.x, this.y,
                                Math.cos(angle) * velocity,
                                Math.sin(angle) * velocity - 0.5,
                                mainColor,
                                2,
                                true,
                                'normal'
                            ));
                        }
                        break;
                        
                    case 'glitter':
                        for (let i = 0; i < 120; i++) {
                            const angle = (Math.PI * 2 / 120) * i;
                            const velocity = 2 + Math.random();
                            const sparkleColor = `hsl(${Math.random() * 60 + 30}, 100%, 70%)`;
                            particles.push(new Particle(
                                this.x, this.y,
                                Math.cos(angle) * velocity,
                                Math.sin(angle) * velocity - 0.5,
                                sparkleColor,
                                2,
                                true,
                                'glitter'
                            ));
                        }
                        break;
                        
                    default: // classic
                        for (let i = 0; i < 100; i++) {
                            const angle = (Math.PI * 2 / 100) * i;
                            const velocity = 3 + Math.random();
                            particles.push(new Particle(
                                this.x, this.y,
                                Math.cos(angle) * velocity,
                                Math.sin(angle) * velocity - 0.5,
                                mainColor,
                                2.5,
                                true,
                                'normal'
                            ));
                        }
                }
            }
            
            draw() {
                if (this.trail.length > 1) {
                    ctx.save();
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 1;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#FFA500';
                    ctx.globalAlpha = 0.8;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x + this.windOffset, this.trail[0].y);
                    
                    for (let i = 1; i < this.trail.length - 1; i++) {
                        const xc = (this.trail[i].x + this.trail[i + 1].x) / 2 + this.windOffset * (i / this.trail.length);
                        const yc = (this.trail[i].y + this.trail[i + 1].y) / 2;
                        ctx.quadraticCurveTo(this.trail[i].x + this.windOffset * (i / this.trail.length), this.trail[i].y, xc, yc);
                    }
                    
                    ctx.stroke();
                    ctx.restore();
                }
                
                if (!this.exploded) {
                    ctx.save();
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#FFA500';
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
                    ctx.restore();
                }
            }
        }
        
        // Sound effects
        function playExplosionSound() {
            const audio = document.getElementById('boom-audio');
            if (audio) {
                const clone = audio.cloneNode();
                clone.volume = 0.15;
                // Add random pitch variation
                clone.playbackRate = 0.85 + Math.random() * 0.3;
                clone.play().catch(e => console.log('Audio play failed:', e));
            }
        }
        
        // Click handler
        canvas.addEventListener('click', (e) => {
            if (rockets.length >= MAX_ROCKETS) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            rockets.push(new Rocket(x, y));
        });
        
        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            reflectionCtx.clearRect(0, 0, reflectionCanvas.width, reflectionCanvas.height);
            
            drawStars();
            
            // Update and draw trail particles
            for (let i = trailParticles.length - 1; i >= 0; i--) {
                const spark = trailParticles[i];
                if (spark.update()) {
                    spark.draw();
                } else {
                    trailParticles.splice(i, 1);
                }
            }
            
            // Update and draw rockets
            for (let i = rockets.length - 1; i >= 0; i--) {
                const rocket = rockets[i];
                if (!rocket.update()) {
                    rockets.splice(i, 1);
                } else {
                    rocket.draw();
                }
            }
            
            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                if (!particle.update()) {
                    particles.splice(i, 1);
                } else {
                    particle.draw();
                    
                    // Water reflection - only for visible particles
                    if (particle.alpha > 0.2 && particle.y < WATER_LINE && particle.y > WATER_LINE - 200) {
                        const reflectionY = WATER_LINE + (WATER_LINE - particle.y) * 0.8;
                        const reflectionAlpha = particle.alpha * 0.3 * (1 - (reflectionY - WATER_LINE) / 200);
                        
                        if (reflectionAlpha > 0.01) {
                            reflectionCtx.save();
                            reflectionCtx.globalAlpha = reflectionAlpha;
                            reflectionCtx.fillStyle = particle.color;
                            
                            const waveOffset = Math.sin(Date.now() * 0.001 + particle.x * 0.01) * 3;
                            reflectionCtx.fillRect(
                                particle.x + waveOffset - particle.size/2,
                                reflectionY - particle.size/2,
                                particle.size,
                                particle.size * 0.8
                            );
                            reflectionCtx.restore();
                        }
                    }
                }
            }
            
            // Particle limit
            if (particles.length > MAX_PARTICLES) {
                particles.splice(0, particles.length - MAX_PARTICLES);
            }
            
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>